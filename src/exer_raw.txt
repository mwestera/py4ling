*** !! NOTE !! Please go to https://github.com/mwestera/py4ling/blob/main/exercises/ for a more readable version of the exercises!


Title	Preparation (Python, PyCharm)

MW  Without searching the web, what do you think Python is?
MW  Without searching the web, how do you think programming works, roughly?
MW  What do you hope to learn or gain from this course? (Simply 'a diploma' is a totally valid answer, albeit somewhat uninspiring.) Write your answer down, and periodically look at it to keep you on track.
MW  This course is for 5 EC. How many hours of study does this represent? Divided over around 15 weeks, how many hours a week does this represent?
MW  Given the foregoing, and your personal goals, how many hours a week do you _want_ to spend on this course?
MW  Go into your calendar and schedule regular, recurring blocks of time in which you will work on this course. Give the recurring calendar event a name that reflects your goal (e.g., `improve my programming` can be better than `Python homework`).

Note    You can write Python programs in any plain text editor (or even with pen on paper!), but many tools exist to make programming easier, safer and more enjoyable. Most programmers work in an **IDE** ('Integrated Development Environment'), which typically contains a text editor with features such as _syntax highlighting_, _style checking_, coding help and auto-completion, as well as tools for running and debugging your programs, version management, even code sharing.

MW  For this course please install the **PyCharm IDE** on your computer: https://www.jetbrains.com/pycharm/ . The 'community edition' is open-source, available for every operating system, and more than sufficient for our needs. Installation is very user-friendly, and you can install it without changing any of the default settings (or tweak them if you know what they do).
MW  Once you have installed PyCharm, execute it (e.g., launch it from the start menu) and on the PyCharm entry screen click the big '+' button to create a _new project_. Again, all the default settings are fine. If Python is not yet installed on your system, PyCharm offers to do this for you when you click "create". Please do so, and again, the default Python version is fine. (To clarify: Python is a programming language. PyCharm is a program to help you write Python programs.)
MW  Inside your newly created project, have a look at the file `main.py` (which, on the default settings, PyCharm will have created for you) and try to run it.

Note  There are two main ways of executing Python code, i.e., of _applying the Python interpreter to your code_. The first is to use the _editor_ to write your Python code a file, and then 'run' the file as a whole. The second is to enter your code in an 'interactive Python interpreter', called **Python console** in PyCharm, executing each command directly.

MW  In PyCharm, see if you can find the editor, the 'run' button, and the Python Console button. <p align="center"><img src="https://raw.githubusercontent.com/mwestera/py4ling/main/src/pycharm.png" width=35% height=35%></p>

MW  As a student you can apply for the free PyCharm _educational license_ (https://www.jetbrains.com/community/education/#students). I would recommend getting this, mainly because it will let you host unlimited sessions of Code With Me (https://www.jetbrains.com/code-with-me/), in case you want to program together with a friend at a distance.


Title   My first Python (`print`, variables, `=`, `==`, `+`, ...)

***Consider separate sections on variables/assignment; arithmetic; booleans.
***Add some interesting reflection/discussion exercises in the middle.

MW	In the Python console, write a print statement such as `print('Hello, world!')` and press the Enter key to execute it.
MW  Write something again, but instead of executing it, cancel it using `ctrl+c` or `cmd+c`. This will be useful to remember.
TP2	When executing a print statement, what happens if you leave out both of the parentheses? What happens if you leave out only the parenthesis open? Or only the closing parenthesis?

Note    Like many IDEs, PyCharm will often auto-complete your parentheses or quotation marks. Hence, if you want to leave out a parenthesis or quotation mark _on purpose_, as required for these exercises, then you need to pay attention that PyCharm didn't mess with what you intended to type.

TP2	If you are trying to print a string, what happens if you leave out one of the quotation marks? (Try both the starting and the ending quotation mark.) What if you leave out both quotation marks? What might the error messages mean?
MW	Try both single and double quotation marks around the string: `print('cheese')` and `print("cheese")`. What happens if you mix different types of quotation marks? Why?
MW  What happens if you use two single quotation marks at the start and end, e.g., `print(''cheese'')`? What if you use three `'''`? (Triple-quotation-marked strings are a bit special; we will learn about them later.)
MW	What happens if you enter `primt('cheese')`? What happens if you enter `print('cheeze')`? Can you explain why?

Note	Whenever you learn something new, stick with it for a while, to explore different variants and _find ways to break it_. By consciously introducing errors and learning to recognize what happens, you will become good at diagnosing the problem when you make unintentional mistakes later.

MW  What happens if you split a print statement over multiple lines, like below. Experiment with different places of putting the newline; which places give an error?\n```
print(
'Hello, world!')
```
MW	Try using the Python console as a calculator, using numbers and operators like + and -. Which operators does Python recognize? What does `**` do?
TP2	What happens if you put a minus sign before a number? What happens if you put a plus sign before a number? What do `2+-2` and `2++2` do? (Spoiler: For readability, you would normally write these as `2 + -2`, or simply `2 - 2`, and `2 + 2`, respectively.)
TP2	In math notation, leading zeros are ok, as in `09`. What happens if you try this in Python?
TP2	What happens if you have two values with no operator between them?
TP3	Add parentheses to the expression `6 * 1 - 2` to change its value from `4` to `-6`.
TP2	How many seconds are there in 42 minutes 42 seconds?
TP2	How many miles are there in 10 kilometers? Hint: there are 1.61 kilometers in a mile.
MW  What does `blabla = 5` do? Subsequently, what does `print(blabla)` do?

Note    The equals sign `=` is used for **assigning** a value (on the right of the `=`) to a variable (on the left). When you subsequently need the same value, you can refer to it using the variable.

MW  Can a variable name contain a number? Can it start with a number? Can it contain a space? A quotation mark? An underscore? Explore what other special characters can be used in your variable names. Try some legal and some illegal variable names.
TP2	Assignment like `n = 42` is legal. What about `42 = n`? And how about `x = y = 1`? If it is legal, what is the result (try printing the variables)?
TP2	In math notation you can multiply variables _x_ and _y_ like this: _xy_. What happens if you try that in Python? Why?
MW  Can you reuse variables, i.e., assign a new value to an existing variable?
P4L	Write and execute three lines of code that: (i) create a variable with the value 37; (ii) create another variable with the value 4; (iii) print out the result of multiplying those variables together.
MW	First enter `n = 42`. Then for each of the following, try to predict what it does, and then try it and make sure you understand what is happening: \n- `n = 100` \n- `n = n` \n- `n = n + 3` \n- `n -= 3` \n- `n = 'n'` \n- `'n' = n` \n- `n = 'n + 3'`
MW	Assign a string like `'hello!'` to a variable, then print it. Now assign a different string to the same variable and print it again. What advantage of variables might this exercise illustrate?
TP3	In the Python console enter `abcdefg + 4`. What happens and why? Next, assign a value to `abcdefg` so that, subsequently, `abcdefg + 4` evaluates to `10`.
TP2	In some languages every statement ends with a semi-colon, `;`. What happens if you put a semi-colon at the end of a Python statement? Or a colon `:`?
TP2	If you run a 10 kilometer race in 42 minutes 42 seconds, what is your average speed in kilometers per hour?
TP2	What is the area of a circle with radius 3? What is the volume of a sphere with radius 5?
MW	Create a Python file (e.g., `exercises2.py`), open it in the editor (if not opened automatically), enter `print('Hello, world!')` in the file and run it.
MW	Compare what happens in the Python console vs. running a Python script containing the same code; try at least: \n- `print('cheese')` vs. `'cheese'` \n- `print(n)` vs. `n` (assuming `n` still has a value from before)
MW	Take a statement that runs (e.g., `print('Hello, world!')`), add one or more spaces in front of it and try to run it again. What happens? Do the console vs. running a script behave the same in this regard?

Note    Unlike in many other programming languages, in Python **indentation is meaningful**. Later we will see cases where you _must_ indent.

TP2	Suppose the cover price of a book is €24.95, but bookstores get a 40% discount. Shipping costs €3 for the first copy and 75 cents for each additional copy. What is the total wholesale cost for 60 copies?
TP3	`%` is the modulo operator, look it up if you need to. Evaluate each of the following numerical expressions in your head, then use the Python console to check your results. What happens in each case? Why? \n- `5 % 2` \n- `9 % 5` \n- `15 % 12` \n- `12 % 15` \n- `238 % 24` \n- `6 % 6` \n- `0 % 7` \n- `7 % 0`
MW  `//` is the integer division operator. What does it do?
MW  Compute in your head (or on paper) the result of `3 * (10 // 3) + 10 % 3`, and verify your own answer by subsequently trying it in Python.

Note	Some of these exercises are about language, or at least about strings like words and sentences; but in these early sections most of them aren't. The initial purpose for these exercises is for you to learn Python syntax and semantics and acquire a programmer's way of thinking. Later we will learn how to apply these skills specifically to natural language.

TP2	If you run a 10 kilometer race in 42 minutes 42 seconds, what is your average pace (time per kilometer in minutes and seconds)? It can be useful to first compute the time per kilometer in seconds and store this in a variable, before processing it further to separate minutes from seconds. (What are some disadvantages if you _don't_ store this intermediate result?)
TP2	If I leave my house at 6:52 am and run 1 km at an easy pace (6:15 per km), then 3 km at tempo (4:42 per km) and 1 km at easy pace again, what time do I get home for breakfast?
MW	What do the built-in functions `max` and `min` do? For example, try `max(3, 4, 5)`, `min(5, -11, -2, 99)`, and `max(10)`; can you guess what the error means?
MW  What happens if you accidentally put a space between the function name and the parentheses (against Python style): `max (3, 4, 5)`? What if you forget the parentheses altogether?
MW	In maths it is common to compare numbers or variables with _greater than_, _smaller than_, _not equal to_, and so on. Experiment with the operators `>`, `<`, `!=`, `>=`, `<=` to figure out what they do.
***[NEW] MW   Some exercise connecting odd/even to the modulo operator.

***Consider separate section on booleans.
***More operator precedence and basic logic exercises.
MW	Put the `not` operator in front of some of the expressions you tested, e.g., `not (3 >= 4)`. What does it do? What about `not True` and `not False`? Inspired by the meaning of the operator `!=`, could you also use exclamation mark `!` instead of `not`?
MW  When using the `not` operator, can you leave out the parentheses, like `not 3 >= 4`? Compare this how the `max` function behaved above.

Note    Python has various built-in **functions** and **operators**. Calling a function (such as `max` and `print`) requires parentheses directly following the function name, with no space (`max(...)`). By contrast, operators (such as `not`) do not require parentheses, and are followed by a space (e.g., `not 3 >= 4`), though often parentheses increase readability (e.g., `not (3 >= 4)`), and they can also matter for operator precedence (see next exercises).

MW	Explore how boolean operators `and` and `or` work. Does `or` correspond to inclusive or exclusive _or_?
***Consider `or`/`and` on stuff other than booleans, and the rightmost-first evaluation. 'a' and 'b' and 'c', 0 and False and '', etc.
MW  Let `cloudy = True` and `windy = True`, and `sunny = not cloudy`, and test whether it is nice day to go to the beach for flying a kite.
MW  Predict, test and explain the difference between `not sunny or cloudy` and `not (sunny or cloudy)`.
MW  Verify your previous explanation by considering the table of **operator precedence** in Python: https://docs.python.org/3/reference/expressions.html#operator-precedence
MW  Ooh, the weather changes! Reassign `cloudy = False`. Did the variable `sunny` automatically update as well?

Note    Variables are 're-assigned' independently of one another. Even if two variables are initially made to refer to the same thing, reassigning something to one variable doesn't automatically reassign the other.

MW  Assign `my_variable = 6`. What happens if you subsequently do `my_other_variable = my_variable`? What if you then reassign `my_variable = 20`, can you predict what happens to the value of `my_other_variable`? Test your prediction.

MW  Numerical expressions can be implicitly converted to boolean values (more about _type conversions_ later). Try to understand this: \n- `not 0` \n- `not 1` \n- `not 100` \n- `not -1`
***Add a note here with the actual rule for this conversion (see notes class2).
***The following exercise has questionable utility; operator precedence is easier to illustrate in a different way.
MW  Given the foregoing, can you predict the value of `not (0 + 1)` vs. `not 0 + 1`? Verify your prediction, and compare it with `not (False or True)` vs. `not False or True`. Make sure you understand this potentially puzzling behavior (see again the _operator precedence_ table).
MW	First enter `n = 42`, and then `n == 42`. What is the result? What about `n == 43`? What happens if you try to assign a new variable with `==`, e.g., `z == 123` (assuming you haven't used `z` before)?
MW	We have already seen you can create a string by using quotation marks. Try to predict which one of these is legal, what the result is, and why: \n- `fruit = 'apple'` \n- `fruit = apple` \n- `'fruit' = 'apple'` \n- `fruit == apple` \n- `'fruit' == 'apple'` \n- `'fruit' == apple`
P4L	What does this code do: `a = 3 == 3`? What is the result and why? What's the difference between that code snippet and this one: `a == 3 = 3`? Why does the latter produce an error?

Note	While single `=` is used for **assigning** a value to a variable, double `==` tests for **equality**. It matters how you read them, whether mentally or out loud. If you read both simply as _'is'_, you are prone to confuse yourself.

TP3	What do these expressions evaluate to? \n- `3 == 3` \n- `3 != 3` \n- `3 >= 4` \n- `not (3 < 4)` \n- `3 % 4 == 0` \n- `3 % 4 == 3` \n- `3 / 4 == 0` \n- `3 // 4 == 0` \n- `3+4 * 2 == 14` \n- `4 - 2 + 2==0`

TP3	Give the logical opposites of these conditions: \n- `a > b` \n- `a >= b` \n- `a >= 18 and day == 3` \n- `a >= 18 and day != 3`.
MW  Given two integer numbers, assigned to variables `x` and `y`, what is the value of `x == (y * (x // y) + x % y)`. Can you change the truth value by changing the numbers assigned to `x` and `y`? How / why not?
TP3	You look at the clock and it is exactly 2pm. You set an alarm to go off in 51 hours. At what time does the alarm go off? (Whenever a value increases and then goes back to zero, again and again, like hours on the clock, modulo can be useful.)
MW	In the interpreter enter `name = input('What is your name?')`. What does it do? Enter something in the interpreter and press enter. Next, look what's in the variable `name`.
MW	In a Python script, write a program that asks for the user's name and prints the name three times (each can be on a separate line).


Title	String operations (`+`, `len`, `[]`, `f''`)

MW	You know that Python can add and multiply numbers with `+` and `*`. Do these operations also work on strings? Try `'apple' + 'pear'`, `'apple' * 'pear'`, `'apple' * 5`, `'pear' + 5` and others. Which mathematical operations work on strings, and which ones don't? Which types of errors do you get?
MW  How do you create an empty string? And a string containing only a space?
MW	How do you add two strings together with a dash "-" in between? And with a space in between? And with five spaces in between?
TP3	For the sentence _All work and no play makes Jack a dull boy_, first store each word in a separate variable, and, using these, print out the sentence on one line.
MW	What happens if you try to create a string, but the string contains a new line, as below? What might `EOL` mean?\n```
sentence = 'apples do not fall
far from the tree'
```
MW	Newlines in your string are no longer a problem if you use triple quotation marks (`'''` or `"""`) instead of single ones (`'` or `"`). Fix the previous code so it runs correctly. If you subsequently print the string, does the newline survive or is it ignored?
MW	You can also add newlines to your string by typing `\n` as part of the string, e.g., `'apples do not fall\nfar from the tree'`. Here backslash `\ ` is used as an _escape operator_; it is used for various other special characters as well, e.g., `\t` for a tab. Very handy! But what should you do if you want to create a string that contains an actual backslash?
MW	Print a string that contains single or double quotation marks, such as the string `She said: "Hello!"` or the string `She said: 'Hello!'`. Can you get it to work (there are several ways)? Can you also print a string that contains both single and double quotation marks?
MW	Do the comparison operators `>` and `<` work on strings, e.g., `'apple' < 'pear'`? What do they mean in this context? Can you explain `'300' > '4'`? What about `'300' > 4`?
P4L	For each of the following, try to predict whether it's true or false (or neither...), verify, and explain why: \n- `'hat' == "hat"` \n- `hat == 'hat'` \n- `1/3 == .33` \n- `'three' > 'two'` \n- `2 + 2 = 4`
MW	What happens if you feed the built-in functions `max` and `min` a string as argument (e.g., `max('apple')`, `min('bonanza')`)? And what about multiple strings, `max('apple', 'aardvark', 'banana', 'zebra')`? Can you explain the result of `max('250')`? And `min('-852')`? And `max('123abc')`?

Note    To get the most out of these exercises, try not to use any built-in methods other than the ones mentioned in the exercises that came before. Later on, we will learn about convenient shortcuts for some of the things you are asked to do, as well as familiarize ourselves with powerful natural language processing libraries. But first we need to put in the manual labor.

MW	What does `len('apple')` do? Apply `len` to different strings.
MW  Can you also get the length of a number, e.g., `len(3)`? What about a boolean? What about the length of the empty string?
MW  What happens if you type `length` instead of `len`? What happens if you forget the quotation marks of the string, or a parenthesis?
MW	The `in` keyword does what you would expect: it checks if one thing is in another. Try `'p' in 'apple'`, and `'q' not in 'apple'`. Can you use `in` to check for larger substrings (e.g., `app`), or only single characters? According to `in`, does a string contain itself?
MW  Can you predict what is going on here? `1 in '123'` vs. `'1' in '123'` vs. `1 in 123`. Verify and explain.
MW	Suppose we have a single character assigned to the variable `char`. In ordinary English, describe what the following means: `char in 'aeoui'`. Does it work on capital letters?
MW	Assign a variable `name = 'Michael'`. What do each of the following do: \n- `name[1]` \n- `name[2]` \n- `name[8]` \n- `name[-1]` \n- `name[-2]` \n- `name[1:3]` \n- `name[2:2]` \n- `name[-2:]` \n- `name[2:]` \n- `name[:2]` \n- `name[0]` \n- `name[2-4]` \n- `name[3-2]` \n- `name[1+1]`

Note    The square brackets operator `[]` lets us select characters, contiguous substrings, and even non-contiguous substrings. This is called _slicing_ the string.

***However, out of range slice indexes are handled gracefully when used for slicing:  >>> word[4:42] 'on'  >>> word[42:]  ''

MW  You can also indicate the _step size_ when slicing, by adding another colon and a number. What does `name[::2]` do? What about `name[::-1]`? And `name[1:5:2]`?
MW  By using _only_ slicing, extract only the odd-position characters from `michael` (assuming the `m` is at position 0, i.e., even). And can you also obtain the string `eh` from the string `michael` by using only slicing? What about the string `ehm`?
***[NEW] MW  By using slicing, write a boolean expression that tests if a given word `w` is a _palindrome_. It should work for words of any length.
MW	Perhaps you'd expect to be able to change the string in `name` by replacing a character like this: `name[2] = 'b'`, expecting the result `Mibhael`. But this doesn't work; what does the error message say? This is because strings are not _mutable_: once you create a string, you cannot change it, only create a new one that is different. We return to mutability later.
MW	Can you predict what `'0123456'[3]` does? What about `'1234567'[3]`? And what about `1234567[3]`?
MW	What does `name[len(name)]` do? What about `name[len(name)-1]`? Why?
MW	Predict the outcomes of `len('apple' * 5)`, `len('apple') * 5` and `len('apple * 5')`, then test your predictions.
MW  Based on what you know about parentheses and spaces in relation to functions vs. operators (see exercise further above), is `len` a function or an operator?
MW	Python's strings have various methods 'attached to them', including `upper` and `lower`. What would you expect them to do? As methods of the string class, you call them like this: `'apple'.upper()`.
MW	For some arbitrary string assigned to variable `s`, is the following true: `s == s.upper().lower()`.
MW  In other programming languages, `len` is sometimes 'attached to' string objects similar to `upper` and `lower`, requiring you to type for example `'apple'.len()` instead of `len('apple')`. What happens if you try the same in Python? Also try the weird-looking `'apple'.__len__()`? Built-in functions and operators in Python are effectively shortcuts for (or implemented via) so-called _dunder_ (double underscore) methods, like `len` is for `.__len__()`.
***Insert A note about functions vs. methods that live on objects.

MW  In a Python script write a program that uses `input` to ask for the user's name, and in response let it print `Hi [name], how are you?`, with the name the user entered.
***[NEW] TP3	Try placing a hashtag `#` before a line of code that previously worked, and record what happens when you rerun the program. Whatever follows `#` is treated as a _comment_ and ignored by Python.
MW	In all of the Python scripts you create, add a _comment_ with the exercise number above the relevant chunk of code, e.g., `# Ex 3.29`, so that you can retrieve your own solutions later. Any text or code preceded by `#` is ignored by Python, as it represents a comment meant for humans.
MW  Write an expression that, given a string `s`, creates a new string that is like `s` but lacks the last 4 characters. What happens if `s` has fewer than 4 characters to begin with?
MW	Write an expression that, given a string `s`, evaluates to `True` if the first character of the string is a vowel, and `False` otherwise. Is your expression robust to capitalization differences? Can you improve this using `upper` or `lower`?
MW	Write an expression that, given a string `s`, evaluates to `True` if the last character of the string is a consonant, and `False` otherwise. Did you use a long string of all consonants, or the boolean operator `not`?
MW	Write a `print` statement that, given a string `s` and an integer `cut_at`, prints two substrings: the starting portion until the position indicated by `cut_at`, and the remainder.
MW  Python's **format strings** can help you easily print stuff in a readable format. You can create a format string in many ways; an easy way is to prefix the string with an `f`, i.e., before the initial quotation mark. Inside a format string, curly braces can contain any Python expression. Make sure `name` contains a string, and try the following:\n```
print(f'Hi, my name is {name}, which starts with "{name[0]}" and is {len(name)} characters long!')
```
MW  What happens if you forget the `f` prefix in the above example?
MW  What happens if you want to print a format string, but somewhere in the curly braces it references a variable that does not exist?
MW  Try printing the same stuff _without_ using a format string. You will need string concatenation instead (`+`), and explicitly convert the length to a string using `str(len(name))` (more about type conversion in the next section). Which version of the print statement do you find more readable?
MW  Format strings have many more options; see what the following do:\n```
my_number = 6.1239871
print(f'{my_number} or {my_number:.6f} or {my_number:.4f} or {my_number:.2f}')

my_string = 'just testing'
print(f'left {my_string:>40} right')
print(f'left {my_string:<40} right')
print(f'left {my_string:^40} right')
```
MW  Use format strings to improve the printed output of some of your time/clock exercises from the previous section.

***Also introduce raw strings here.

Title	Types (`type`, and `int`, `str`, ..., also `help`, `dir`)

***tuple syntax, e.g.,  a = 3 + 4,  error.

MW	What does the built-in function `type` do? Apply it at least to the expressions `4`, `238`, `-6`, `5.3`, `3 ** 4`, `'apple'`, `'apple' * 5`, `True`, `False`, `'True'`, `'False'`, `'987'` (note the quotation marks), `print` and `max`.
MW	You can _convert_ between types by using `int`, `str`, `float`, `bool`, for instance `int('400')` constructs a string `'400'` from the integer `400`, and `bool(0)` constructs the boolean `False` from the integer `0`. Try to convert between different types, and use `type` to check the result.
MW  What happens for conversions that don't make sense, e.g., `int('apple')`, `float('')`?
MW	Try `bool('True')` and `bool('False')`. Is the result what you expected? Try to understand why this is. Can you guess what string do you need to feed to `bool` to get `False`?
MW	What happens if you try to append a number to a string by doing `'apple' + 5`? Can you fix this by using `str`? (Of course you can also create a string directly with quotation marks, e.g., `'5'`, but here we are practicing explicit conversion.)
MW	Can you divide an integer number such as `5` directly by a floating point number such as `3.14`, or does this require explicit type conversion?
MW  Does division always result in a float, or only when the result is not a whole number? For instance, what about `6/3` (e.g., compared to `6/4`)?
MW	Is `5.0000` a float or an int? What do you expect will be the value of `5.0000 == 5`?
MW  Remember that Python does not allow zero prefixes on integers, e.g., it complains when you do `some_number = 000123`. What do you think will happen if you do `int('000123')`? Given this, can you argue that converting strings to numbers is more lenient than the Python interpreter itself?
MW	If you get a user's input using `input`, what is the type of the resulting object? Does this depend on what the user enters?
MW	In a Python script, write a program that gets a number from the user, multiplies it times 5, and prints the result.
MW  Given what you have learned, if you add up two floats that together happen to form a round number (like `0.4 + 0.6`), does the outcome automatically become of type `int`?
MW  While the Python console is useful for trying out a single command, writing longer programs is much more convenient to do in a file in the editor. Can you think of some reasons why?

Note	When you are asked to 'write a program', you can either create a new `.py` file (and make sure you subsequently run the new file), or continue working in an existing file from a previous exercise. As long as the previous code doesn't give errors, take too long to run, etc., continuing in the same file is fine! Later we will learn how to better structure your files and code. For now, make sure to choose sensible file names, and always add a **comment** with the exercise number(s) above each chunk of code, e.g., `# Ex 4.13`.

MW	Write a program that gets one number from the user, then another one, and prints the result of dividing the first by the second. Try it out a couple of times. What happens if you run the program, first enter 9 and then 0?
MW	To test if an object is of a certain type, use `isinstance`, for instance `isinstance(500, int)` and `isinstance('apple', str)`. What is the type of `isinstance` itself?
MW	Types form a hierarchy, as you would expect, e.g., just like a mammal is also an animal, a string (type `str`) is at the same time also an object (type `object`), which is a more general, super-type. Test this with `isinstance('apple', str)` and `isinstance('apple', object)`. When you use `type`, it looks only at its lowest type in the hierarchy. Can you compare and explain the values of `isinstance('apple', object)` and `type('apple') == object`?
P4L	What does this code do: `isinstance(bool == bool, bool)`? What is the output and why?
***Not very informative: MW  What might be going on here: `0.1 + 0.2 == 0.3`? It tells you _something_ (but not much) about how Python (and many other programming languages) internally represents floats.
MW	`help` is a built-in function that gives you information about other functions. Try `help(max)`, `help(min)` (pressing `q` lets you quit the help screen).
P4L	Use the `help` function to find out about the `round` function. Explore how to use it, with one and with two arguments.
MW	Use `type` to test whether `round` changes a float into an int. Does it _always_ do this?
MW	Note that `print` can take multiple arguments, e.g., `print('apple', 'pear', 'banana')`. Use `help` to learn more about the `print` function. You will likely not understanding everything, but you can play around with the parameters `sep` and `end`.
MW	Why doesn't `print('Hello', 'world!')` print `Hello, world!`?
MW	Now that you have used the Python console for a while, enter `dir()` in the interpreter to show the 'directory', a list of names of all objects currently available (at least those in the _global scope_, about which we will learn later). As you will see, any variables previously created still exist (alongside some automatically created variables like `__name__`, about which we will also learn later). In PyCharm's Python Console, variables and their values are also standardly displayed in a separate panel on the right.
MW	If you mistype `primt('apple')` instead of `print('apple')`, you would normally get the informative error _Name is not defined_ to notify you of this mistake: the name `primt` does not appear in the `dir()`. But what if you defined a variable `primt = 5` long ago and you forgot about it? If you then make the typo `primt('apple')`, the error you get will be much harder to understand (unless you remember you still had the `primt` variable hanging around from earlier).

Note	If you keep too many old names hanging around in the interpreter, this can make it more difficult to _detect mistakes_. To reduce this problem, occasionally restart your Python console (especially if you keep getting unexpected results). When you run code from python scripts (instead of the interpreter directly) this problem is less likely to occur, as each time you run a script, Python starts from scratch. However, if keep working in the same file for too long, the problem can reappear. (To help with the latter, programmers _encapsulate_ chunks of code; we will learn about this later.)

MW  Verify that running a Python script starts the Python interpreter from scratch (at least with the 'run' button in PyCharm...), in particular that it removes any variables defined in a previous run. You can test this by first running a script that creates a certain variable (and then uses it, e.g., printing it), then change the script by removing the line that created the variable, and try to run it again.
MW  In a Python script, write a program that asks for the user's age in years and prints several things: their age in months, their age in weeks, their age in days, their age in hours, their age in minutes, and their age in seconds; you can ignore leap years (and make other simplifying approximations). Is your program making the same (pieces of) computations multiple times? If so, consider storing intermediate results in auxiliary variables.
TP3 Write a program that uses `input` to ask the user for the time now (in hours), and subsequently asks for the number of hours to wait. Your program should store each user response in a variable, and print what the time will be on the clock when the alarm goes off.
MW  When doing linguistic research, what kinds of data would you likely represent in the form of strings? What could be some linguistic uses of integers? What about floats?
MW  Let's zoom out a bit, and consider what types of linguistic research might require programming to begin with. Try to come up with several, varied examples of research questions that could require, or at least benefit from, programming.

*** TODO Add an exercise about individual digits.
*** [NEW] Note	In programming, an important part of the solution to any problem is often: how should I represent my data? For instance, should you represent a number as an int or as a string? If the goal is to do arithmetic, it makes sense to treat it as a number; but if the goal is to count digits, it can be helpful to first represent the number as a string.


Title	If-clauses (`if`, `elif`, `else`)

Mw  Create a Python script with the following, predict what it does and test your prediction:\n```
if 4 + 2 == 6:
    print('yes!')
```
MW  Remember: after learning something new, stay with it for a while, exploring it and finding ways to break it. To that end, modify various things in the above example, e.g., what if you replace `==` by `=`? (Undo that.) What if you remove the colon `:`? (Undo that.) What if you change the condition (`4 + 2 == 6`) into something that is always false?

Note  The `if`-clause consists of a **header** `if 4 + 2 == 6:` and a **suite** `print('yes!')`, also called the **body** of the if-clause. We will see various other types of clauses later, always consisting of a header and a suite, e.g., for-loops and function definitions. The header of a clause always ends with a colon `:`. The suite/body typically starts on a new line, and must be indented.

MW	What happens if you remove the indentation, i.e., if header and suite start at the same level?
MW  What if you place the print statement on the same line as the if-statement, i.e., after the colon?
MW	What is being printed by the following program:\n```
if 1 + 1 == 5:
    print('uuuuhm...')

print('print this!')
```
MW	What happens if you indent the second print statement to the same level as the first print statement? (Undo that.) What if you replace the condition by something true? What happens if you remove the newline between the two statements? What if you indent the second print statement again, but now add several newlines between the two print statements?

Note	_Indentation is meaningful_ in Python, whereas in most other programming languages it is only an optional style convention.

MW	In your Python editor (or the interpreter), can you indent with the 'tab' key? Do these appear as proper tabs (large spaces) or are they replaced by sequences of multiple normal, narrow spaces? If the latter, you're safe; if the former, you need to pay extra attention: you can indent either with tabs or with spaces, but don't mix them!
MW	Write a program that, given a variable `n` with a number, tests if its value is odd, and if not, adds 1 to it and prints _I've made it even!_. Subsequently, regardless of whether it was originally even or odd, the program should always print the resulting value of `n`.
MW	Write a program that, given a variable `name` containing a string, tests if the first letter is `a`, and, if so, prints _The first letter is 'a'!_. Only if the first letter is 'a', it should additionally test if the second letter is 'b', and if so, print _The word starts with 'ab'!_. Your second `if` can be nested under the first `if` -- make sure the indentation reflects this. Apply your program to a number of strings to test, such as _able_, _apple_ and _banana_.
MW	Write a program that asks for the user's name, tests if it starts with a vowel, and if so, prints _You are a vowel person!_.
MW	Are the headers `if True:` and `if False:` accepted by Python (together with a suitable suite)? What do these conditions achieve?
MW	You can follow an if-clause with an else-clause, which consists of its head `else:` and one or more statements as a suite. Use `else:` to expand the previous program to print _You are a consonant person!_ in the right circumstances.
MW	Is your program robust to users (not) capitalizing their name?
MW	Now write a program that basically does the same, but is coded in the reverse order: it first tests if the name starts with a _consonant_, and if so prints _You are a consonant person!_; otherwise print _You are a vowel person!_. Did you type a long string of all the consonants to implement this? If so, could this be avoided?
MW	Write a program that tests whether the value of a variable `n` is odd (i.e., not divisible by 2), if so print _Odd!_, and if not print _Even!_.
MW	Oops, our client requests a change: they want to the program to print, on the same line as _Odd!/Even!_, whether the number `n` is greater than 10, equal to 10, or smaller than 10.
MW	Our client requests another feature: if the number is both odd and greater than ten, that's a very special case where it should print only _ALARM!!!_ and nothing else.
MW	Python's `elif` is shorthand for `else, if`. Can you predict what the following program does?\n```
if n > 0:
    print('Positive!')
elif n == 0:
    print('Zero!')
else:
    print('Negative!')
```
MW	Together, the if-clause, elif-clause and else-clause form a **compound clause**. Can you have an `elif` and/or an `else` clause without an initial `if` clause? Can you have more than one `elif`?
MW  What happens if you specify a condition also in the `else` header, e.g., `else n < 0:`?
MW	In an if-elif-else compound clause, what happens if one of the three clauses has an empty suite (e.g., delete or comment out (`#`) one of the print statements in the code above).

***The following is not great; flattening if/thens isn't super relevant yet.

MW	If possible, use `elif` to improve the readability of the 'odd/even/greater than 10' program from a few exercises ago, for instance by avoiding (deeply) nested if-clauses.

Note	Nested if-clauses are frowned upon as an 'anti-pattern' in programming, to be avoided because they make code difficult to read and maintain -- and this applies not only to `if`-clauses (see also `for`-clauses below).

MW	We both flip a coin (outside Python), and manually store the outcomes in two boolean variables `player1` and `player2`. If both came up heads, print _We both won!_, if both came up tails, print _Play again._, if only the first comes up heads, print _Player one won._, if the second, print _Player two won._.
MW  Does your code for the previous exercise contain nested if-clauses? Implement a version without nested if-clauses. Besides `elif`, you can also reduce nested ifs by combining your conditions using boolean operators like `and` and `or`.
MW  How often does your coin-flip program check the variables `player1` and `player2`? If either variable is checked more than twice, you are checking more than you need to; try to simplify your code.
MW	Write a program that takes two strings from the user (one after the other). If either one is less than three characters long, it prints _You are disqualified_. Otherwise, if the two strings are not equal but one string is contained in the other, it prints _Yay well done!_, otherwise _Nope_.
MW	Write a program that takes a word as input from the user, and checks the first two characters: if one is a vowel and the other a consonant (in either order), create a new string where the two characters are swapped; otherwise leave the string unchanged. Print the resulting string. Can you think of an English word that turns into another proper English word?
MW  Write a program that takes a word as input from the user, tests a number of things in a row, and prints a single line of appropriate feedback: \n- whether it starts with two vowels, with a single vowel, or with a consonant \n- whether it has an even or odd number of characters \n- if odd, what the middle character is, and if even, what the middle two characters are \n- whether it is a palindrome (hint: use string slicing).



Title	Defining and calling functions (`def`, `return`)

MW	In a python script, enter the following code to define a function with the name `print_spam` and subsequently _call_ it (do you remember why the string definitions involve a backslash at `I\'m`?):\n```
print('I\'m going to define a function.')

def print_spam():
    print('spam')


print('Now I\'m going to call the function, pay attention:')
print_spam()
```
MW	A function definition is a _clause_, just like an if-clause (and others about which we will learn later). What is its head and what is its suite/body?

***First: can a function call itself?

MW	What happens in the above example if there is only one empty line after the function definition (it will run, but your editor may complain)? What if there is no empty line after the function definition? What if either or both of the last two print statements in the above example are indented too?
MW	Can a function contain multiple statements in its body? Can you call the same function multiple times?
MW	What happens if you define a function but don't call it? What happens if, in the function _call_, you forget the parentheses, i.e., `print_spam` instead of `print_spam()`?
MW	What do you think will happen if your script calls a function _before_ defining it (i.e., in the .py file, the definition comes after the call)? Test your expectation.
MW	What happens if you change the name of the function in the definition, but forget to update the function call?
MW	When defining a function, you can give it **parameters**, enabling it to be called with **arguments**. Make sure you understand the following:\n```
def print_twice(word):
    print(word)
    print(word)


print_twice('bla')
```
MW	What happens if you accidentally call the original `print_spam` from further above, which has no parameters, with an argument, e.g., `print_spam('bla')`? Conversely, what if you call `print_twice`, which does have a parameter, without an argument?
MW	Define and call a function `print_inverted` that is given a word, and prints the word back-to-front (e.g., _apple_ is printed as _elppa_). (Hint: String slicing can be helpful here.)
MW	Does a function definition (a def-clause) follow the same indentation rules as an if-clause and a for-clause?

MW  Instead of directly printing something to the user, a function can also `return` a value to the program, i.e., back to where the function was called, for subsequent processing. Run this example and try to understand what it does:\n```
def give_me_spam():
    return 'spam'


some_spam = give_me_spam()
even_more_spam = some_spam.upper() * 5 + '!!!'
print(even_more_spam)
```
MW	The following code (when executed from a file, _not_ the console) does not print `aaah!`. Make the program print capitalized `AAAH!` _without_ changing the function definition, by doing something with the result of the function call.\n```
def create_scream():
    return 'aaah!'


create_scream()
```
TP3	Write a function called `is_even` that takes an integer `n` as an argument and returns (_not_ prints) `True` if the argument is an even number and `False` if it is odd. Test the function by applying it to several numbers, one after the other, and print all test results at once.
TP3	Now write the function `is_odd` that returns `True` when its integer argument `n` is odd and `False` otherwise. To reduce redundancy in your code, you can define this function in terms of the previous function `is_even`.
MW  What happens if you try to print the supposed 'output' of a function that in fact has no `return` statement, such as the `print_spam` function from earlier? For instance, try:\n```
result = print_spam()
print('the result is:', result)
```

Note    A function can not only take inputs and 'do' stuff (such as print it out to the user), it can also **return** a value, i.e., give it back to wherever in the program the function was called, a value which can then be used for subsequent processing. A function that has no return statement returns nothing, or rather, it returns the special object `None`.

TP3	Write a function called `hypotenuse` that returns the length of the hypotenuse (Dutch: 'schuine zijde') of a right triangle, given the lengths of the two legs adjacent to the right angle as parameters. Examples: `hypotenuse(3, 4) == 5.0`, `hypotenuse(24, 7) == 25.0`. For a square root function, you can do `import math` and then use `math.sqrt`.
MW	Define and call a function `invert` that takes a word, and returns a new string representing that word back-to-front (that is, like `print_inverted`, but instead of printing the inverted word, it returns it to the program for subsequent processing). In your program (outside the function definition), apply the function to some word and then print that word and its mirror image next to each other.
TP2 Do you remember how to use _format strings_ to align a string left, center or right? Try this again. Now write your own function named `right_justify`, _without_ using format strings (for the sake of practice), that takes a string named `s` as a parameter and returns the string with enough leading spaces so that (when printing it) the last letter of the string would be in column 40 of the display.
MW	Still without using format strings in the function definition, add a parameter to the previous function, such that you can also choose a column other than 40.
MW	Remember `type` from before? What do you expect `type(create_scream())` and `type(invert())` to be (assuming you still have `create_screen` and `invert` defined from above)? Test your expectations. And what is the type of (the result of) calling a function that does not return anything, e.g., `print_spam()` from above?
MW	Explain the difference between `type(create_scream())` and `type(create_scream)`; and between `type(print_spam())` and `type(print_spam)`.
MW	What happens if a single function contains multiple different `return` statements (e.g., `return 'haha!'` and `return 'hehehe...'`)?
MW	Define and call a function that both prints a string and returns another string (against recommended practice).

Note	As a rule of thumb, every function should either _return_ stuff (e.g., compute and return some value) or _do_ stuff (e.g., print stuff, modify an existing object), not both. Functions that return stuff are sometimes called fruitful functions; functions that only do stuff are sometimes called procedures. A function that does both is said to have **side effects**, which is considered an 'anti-pattern' (i.e., to be avoided) in programming.

MW	Functions can also have multiple parameters (hence be called with multiple arguments). Write a function that takes three numbers and returns their sum, and a function that takes three numbers and returns their average.
MW	What happens if you define a function with one parameter (like `invert` above), but wrongly call the function as if it has two parameters (e.g., `invert('abc', 'def')`)? Conversely, what if you wrongly call a function that has two parameters, as if it has only one?
MW	Write a function `is_palindrome` that takes a word, and checks if it is a palindrome, returning `True` or `False` accordingly. Can you implement a version that uses your `invert` function from above?
TP3	Write a `compare` function with two parameters `a` and `b`, that returns `1` if `a > b`, `0` if `a == b`, and `-1` if `a < b`. Examples:\n- `compare(5, 4) == 1` \n- `compare(7, 7) == 0` \n- `compare(2, 3) == -1`

MW	It is easy to misunderstand or forget what a function is supposed to be doing, even if you yourself wrote it. To avoid this you should _document_ your code. Adding informative `#`-comments is one way (caveat: `#`-comments can often be replaced by making your code more 'self-documenting', about which we will learn later). Another, very important way to document your code is with so-called _docstrings_ (documentation strings): a string object that occurs in the first line(s) of a function definition. Try this:\n```
def sum_three_numbers(a, b, c):
	"""Takes three integers or floats and returns their sum."""
	return a + b + c
```
MW	Python internally handles docstrings by storing them as properties of the function, in a special field `___doc__`. Try `print(sum_three_numbers.__doc__)`. Docstrings are accessed, for instance, by the `help` function; try `help(sum_three_numbers)` (remember you can press `q` to quit the help).
MW	Docstrings are customarily defined using three double-quotation marks (`"""..."""`). Do you remember how they handle newlines? Can you also also define docstrings using single double-quotation marks (`"..."`), i.e., does the `help` function still pick it up? What about using three single-quotation marks (`'''...'''`) or a single single-quotation mark (`'...'`)?

Note	Always start your function definition with a **docstring**, explaining at least what arguments the function takes and what it does or returns. When programming, you can even write the docstring prior to writing the body of the function definition, to guide the actual implementation.

MW	Add docstrings to all the functions you defined so far. (This is not just a chore; re-reading your own code from previous exercises, and remembering/reconstructing what it is supposed to do, is a useful exercise in its own right.) Your docstrings can also mention the exercise number for which the function was written.
TP3	Write a function `is_factor` with integer parameters `f`, `n` that makes each of the following statements evaluate to `True`: \n- `is_factor(3, 12)` \n- `not is_factor(5, 12)` \n- `is_factor(7, 14)` \n- `not is_factor(7, 15)` \n- `is_factor(1, 15)` \n- `is_factor(15, 15)` \n- `not is_factor(25, 15)`.
TP3	Write a function `is_multiple` to satisfy these statements: \n- `is_multiple(12, 3)` \n- `is_multiple(12, 4)` \n- `not is_multiple(12, 5)` \n- `is_multiple(12, 6)` \n- `not is_multiple(12, 7)`.

Note    Sets of statements like the foregoing are useful for **testing** that your function works correctly. Indeed, although most of these exercises do not explicitly tell you, you should always _test_ your function thoroughly, to ascertain it works correctly. Testing your function on one example is never sufficient, and always consider possible _edge cases_ (e.g., negative numbers, zero, empty lists, empty strings). (Later we will learn how to write code in a separate file for exactly that purpose: testing testing testing.)

TP3	Write the function `farenheit_to_celcius` designed to return the integer value of the nearest degree Celsius for given temperature in Fahrenheit, and its inverse `celcius_to_farenheit`. Extract suitable test cases from a conversion table on the web.
MW  Write a function `is_determiner` that checks if a given word is an English determiner (for practice reasons, try to do this without first storing an inventory of determiners in a _list_, which will be properly introduced in the next section). It should return True or False accordingly.
MW  In PyCharm and many other IDEs you can ctrl+click (or cmd+click) on a function call, to jump to the place in the code where the function is defined. Clicking on a variable in this way brings you to the place where it is first assigned. It is true also for built-in functions, and functions imported from other modules, in which case PyCharm takes you to the corresponding source files as well. Try ctrl+click a bunch of times on different functions and variables.


Title	Lists (`list`, `append`, `[]`)

MW	Assign a variable `names = ['Alf', 'Beth', 'Chris', 'Dave', 'Esra']`. What does `type(names)` say?
MW	Use square brackets `[` and `]` to create a list of numbers, a list of strings, and a list of both numbers and strings. Do these lists all have the same `type`? What about an empty list?
MW	What happens if you try to create a list but forget a comma? What if you forget a square bracket? Is it legal to put each list item on a separate line (i.e., newlines after each comma)?
MW	Can you also create a nested _list of lists_? And a list of lists of lists?
MW	Using the previous list `names`, try to predict what the following do (just as with strings, this is called _slicing_), and test your predictions: \n - `names[1]` \n - `names[2]` \n - `names[8]` \n - `names[-1]` \n - `names[-2]` \n - `names[1:3]` \n - `names[2:2]` \n - `names[-2:]` \n - `names[2:]` \n - `names[:2]` \n - `names[0]` \n - `names[2-4]` \n - `names[3-2]` \n - `names[1+1]`
MW	Earlier we used `len` for strings. Does it also work on lists? What about an empty list?
MW	What do you expect will happen if you do `names[len(names)]`? Test your expectation, and try to understand why you were wrong/right.
MW	Recall from slicing with strings that you could specify not only a start and end, but also a step. Does this work with lists? For instance, use slicing to construct a sub-list containing only the elements at even indices (0, 2, 4, ...), or only at odd indices, or to construct the inverse of a list (by slicing it from back to front).
MW	What happens if you pass an entire list as an argument to `print`, i.e., `print(names)`?
MW	Assuming you still have the variable `names`, what does the `in` keyword do? Try at least `'Alf' in names` and `'Alwyn' in names`. How do you test whether _Alwyn_ is _not_ in `names`. Is the `in` keyword (or rather, the notion of 'string identity' on which it relies) case-sensitive?
***TODO add an exercise about repeated slicing to get into a nested list of lists.
***TODO Add remark/exercise about this: In the case of strings, `in` also tests for subsequence; not so for lists.
MW	Remember that various numerical operations could be performed on strings, e.g., `'apple' * 5`, and `'apple' + 'pear'`. Do such oprations also work on lists?
MW	You can change a list element at a given position (index) by assigning a new value using `=`, e.g., `names[3] = 'Nick'`. Afterwards, print the list `names` to see the effect.
MW	In the list `names`, use assign to replace the last element by 'Suzy' and the first element by 'Bob'. Can you also use assignment to _extend_ the list, by assigning a new element to the final index plus 1?
MW	Adding elements at the end of a list can be done, instead, with `append`. This is a method of the list class, hence you call it 'on' a list with a period `.`, like `names.append('Ann')`. Try appending several names to `names`, and finally print the length of the resulting list.
MW  Assign an empty list to a variable, and then `append` a bunch of things to it. Print the result.
***Insert exercise about a = a.append('test')
***Insert exercise about my_list.append(1000) what is the resulting length?
***Insert exercise about concatenation vs append; what if you concatenate with a single element, etc, try to append a list.
***Insert about [1, 2, 3] + 'abc' works, but 'abc' + [1, 2, 3] doesn't.
MW  Write down your expectation, and then test it: What happens if you append an object to a list that already contains it? And what happens if you define a list in which the same object occurs multiple times from the start?
MW	So far, you first assigned a list to the variable `names`, then changed the list, and then you inspected the original variable `names` to see the result. However, at no point did you _reassign_ an updated list to `names`. Rather, the same list remained assigned to `names`; it is the list itself that was modified. This is possible because lists are _mutable_, unlike integers or strings. In comparison, there is no way to _change_ the integer or string value of a variable, _except_ by reassigning something new to it. To better understand this, reflect on the following code:\n```
int1 = 5
int2 = int1
int1 += 6
print('int1:', int1, '   int2:', int2)

str1 = 'bla'
str2 = str1
str1 *= 2
print('str1:', str1, '   str2:', str2)


list1 = ['a', 'nice', 'list']
list2 = list1
list1.append('really')

print('list1:', list1, '   list2:', list2)
```
MW  One way of modifying a list in-place is by assigning a new value to an existing position in the list, as we saw above (e.g., `names[3] = 'Nick'`). Do you remember whether you can similarly change a string by assigning a character to a position, e.g., `str1[1] = 'z'`? Try it, and compare this to how a list behaves.

Note    Lists are **mutable**: they can be changed in-place (e.g., using `append` or by assigning something to an index in the list). This means that the 'contents' of a variable to which a list is assigned can change, without ever needing to reassign an updated list to that variable. By contrast, strings and ints (and floats, and bools, and tuples) are _immutable_: e.g., the only way to change the value of a variable that refers to a string, is by reassigning a new string to that variable. Understanding mutability will help prevent some hard-to-track mistakes later on!

MW  Based on the foregoing, do you expect strings to have an `append` method just like lists? Why (not)? Try it.
P4L	But if strings are really immutable, what is going on below? The value of `x` seems to change! Explain what's going on; is a string mutable after all?\n```
x = 'abc'
print(x)
x = x.upper()
print(x)
```
MW  Given some list `my_list`, do you remember what this slicing notation does: `my_list[:]`? Is the resulting object the same list as the one originally assigned to `my_list`, or does it merely have the same elements? Test this by trying to modify one without modifying the other.
AMY Here is a fun puzzle related to mutability. For the game of tic-tac-toe, we can construct a 3x3 board as follows: `row = [''] * 3`, and then  `board = [row] * 3`. See what the `board` looks like, and optionally write a function to print it in a prettier way. Now let's play the game: I'm the first player, and I place a cross in _one_ of the cells, like this: `board[1][1] = 'x'`. Let's print the board again. Oops, it appears I already won! Easiest game of tic-tac-toe! (What on earth is going on??) How should the `board` have been constructed to prevent this cheat?
G4G	Define a function `swap_first_and_last` that takes a list and swaps the first and last elements, modifying the list in-place. Does your program work if the list has only one element? What should it do if the input list has zero elements?
MW  Make your previous function more sophisticated by giving it an additional parameter `in_place`, a boolean that indicates whether the function should modify the list in-place (and return nothing) or make a changed copy instead (and return that). Change the rest of the function accordingly, to handle this parameter. If `in_place` is set to False, your function should also be able to work on strings.
TP3	Assume the days of the week are numbered 0,1,2,3,4,5,6 from Monday to Sunday. Write a function `day_number_to_name` that asks a day number, and returns the day name (a string). Call the function with some values to test it.
MW	Oops! Your client prefers to number the days from 1 (Monday) to 7 (Sunday). Can you modify the above program to fit their use case? How many changes did you need to make?
MW	In the above function, did you use `if` statements? Try to write this program without using `if` statements, by using a list of day names instead. Does this make the program easier to modify if the client changes their mind again?

Note	Whenever you need a mapping from (consecutive) integer numbers to something else, such as strings, use a list, which is precisely such a mapping. For a mapping from things other than integer numbers, we will learn about another data structure later, the _dictionary_.

TP3	You go on a wonderful holiday leaving on day number 3 (a Wednesday). You return home after 137 nights. Write a function that takes a starting day number and a duration (in number of nights) as parameters, and it will tell you the name of day of the week on which you will return.
TP3	Can your function from the previous exercise already work with a negative number of nights? For example, -1 would be yesterday, and -7 would be a week ago. If your function already works, explain why. If it does not work, try to fix it. Consider how the modulo `%` operator works on negative numbers.
P4L	Lists and strings are similar in many ways. Try to show with code several ways in which they are alike, and ways in which they are not alike.
MW	Do you expect the following to be true or false: `len([1, 2, 3]) == len('[1, 2, 3]')`. Test your expectation.
MW	In the section on types we saw how to build a string from an int (`str(5)`), an int from a string (`int('24')`), etc., essentially converting between types. Similarly, you can build a list from various types of objects, using `list`. Try 'converting' a string to a list, and understand what you see. Can you also convert a list to a string? Do you expect the following to be true: `str(list('apple')) == 'apple'`? Is it? Why (not)?
MW  What happens if you define your own variable with the name `list` (or `str`, or `int`, for that matter)? Why might doing so be a bad idea?
G4G	Write a function with three parameters that, given a list and two integer positions in the list, swaps the two elements in the list. Does your function modify the input list _in-place_, or create a new list?
MW	Write an analogous function (or at least 'as analogous as possible') for swapping two characters in a string.
MW  If applicable, improve your function `is_determiner` from the end of the previous section, which checks whether a given word is an English determiner, by first storing the determiners in a convenient list.
MW	Define a function that generates random, simple sentences of the shape "{determiner} {noun} {verb}s" (e.g., "the student walks"). Use separate lists to store a bunch of lexical items of the required syntactic categories. At the top of your program add `import random`, which lets you use the function `random.choice` to randomly select an item from a list. (We will learn more about `import` as well as `random` later.) Select random items from the appropriate lists and compose a string from them, printing the final result.
MW  Make your random sentence generator as advanced as you like (though try to use only Python constructs that have been introduced in the exercises so far). For instance, can you extend it to randomly choose between an intransitive and a transitive verb frame, and then choose the right type of verb and include a direct object if the verb is transitive?

***Consider introducing list-to-string methods join and split here. May require revising some exercises in next section about tokenizing etc.


Title	For-loops (`for`)

MW	Another keyword that can create clauses is `for`. Try to understand what it does, with the following code. First make sure the variable `names` is still assigned the list of names `['Alf', 'Beth', 'Chris', 'Dave', 'Esra']`.\n```
for name in names:
    print(name)
```
MW	Is indentation meaningful in the case of for-clauses, too? Verify this empirically.
MW	After executing the above code, do you expect that the variable `name` has a value? If so, which value? Test this and make sure you understand what is going on.
MW	Write a program that loops over the list `names` from above and prints each element twice, using a `for`-loop with two `print` statements in its body.
MW	What happens if the variable `name` already exists before executing the for-loop? (Perhaps this was already the case in the previous exercises.)
MW	Write a function `print_multiple` that is given a list, and prints each element of the list, each on a new line.
MW  Can you predict what will happen if you accidentally do `print_multiple(name)` instead of `print_multiple(names)`? Test your understanding.
MW	Write a function `print_multiple_oneline` that is given a list, and prints all list elements on a single line, concatenated with dashes in between. You can either first compose a long string and call `print` only once at the end, or use repeated `print` statements and control the layout with the help of its `end` parameter.
MW	Modify the original `print_multiple` to take an additional boolean argument `oneline`, such that `print_multiple([1, 2, 3], True)` prints all numbers on one line with dashes in between, and `print_multiple([1, 2, 3], False)` prints each number on a new line.
TP3	You can also initialize a variable outside the for-loop, and then modify or reassign something to it on each iteration within the for-loop. Use this to write a function that takes a list `numbers`, and loops through it to compute the sum of the squares of the numbers, returning it in the end. For example a call with `[2, 3, 4]` as an argument should return the result of 4+9+16 which is `29`
MW	Define a function `length` that takes a list as input and returns its length, _without_ using the built-in function `len`.
MW	Write a function that takes a list of words and concatenates them, placing one after the other with dashes `-` in between, and returns (not prints) the resulting string. (Try not to use built-in functions other than those introduced so far.)
MW	Generalize the preceding function to allow changing the separator (e.g., dash, space, underscore) by giving the function an extra parameter `sep`.

Note    After defining a function, make sure to _test_ it thoroughly by calling it with various arguments. After verifying that it works, you can easily comment out (with `#`) the test function calls, while leaving the function definition itself untouched. This lets you conveniently work in a single file for all the exercises, without all the previous functions being called every time you test the latest function. Later we will learn how to separate the test calls from the function definitions.

TP3	Can you use an if-clause within a for-loop? Write a function to count how many odd numbers are in a list, returning the result.
TP3	Define a function that sums up all the even numbers in a list, returning the result.
TP3	Define a function that sums up all the negative numbers in a list, returning the result. As always, try to use a clear, transparent function name.
MW  Write a function that takes a list of numbers, multiplies each element by 3 and appends the results to a new list. Does the new list have the same number of elements as the original list?
TP3	Write a function that takes a list of words, and an integer, and counts how many words in the list have a length of at least that integer.
TP3	One way to escape a loop early, at least inside a function definition, is the `return` statement. Write a function that sums all the elements in a list up to, and including, the first even number, and then returns the result right away (skipping the rest of the list). (What if there is no even number in the list?)
MW  Extend the previous function with a boolean parameter `inclusive`: setting it to False should result in summing up to, but _excluding_, the first even number.
TP3	Write a function that counts how many words occur in a list up to (and including) the first occurrence of the word _the_.
MW	Just as you can loop through a list, you can loop through the characters of a string. Write a function `has_even_vowel_count` that uses a loop to count the number of vowels in a string, and returns a boolean that indicates whether that number is even or not.
MW  Did you remember to add docstrings to your functions?
TP3	Write a function that counts the number of even digits in a number `n`, e.g., the number `5671238` has 3 even digits (6, 2 and 8).

Subtitle    List comprehension

***Explain generator objects here**

MW	The keyword `for` also appears in a powerful and 'Pythonic' pattern called **list comprehension**. With a single line of code, it lets you construct a new list from an old one by changing or filtering the original elements. Try to predict (and test) what the following do:\n- Let `numbers = [9, 5, 8, 3, 2, 6]`, and try `[n for n in numbers if n > 4]` \n- Assuming you still have `names` assigned: `[s[0] for s in names]` (if you were to assign the result to a variable, what would be a fitting variable name?) \n- `[name[::-1] for name in names]` \n- `[s for s in names if s[0].lower() in 'aeiou']` (try to describe what this means, in plain English)
MW  Use list comprehension to take a list of words, and construct a list of the same words but in full capitals. Does your code demonstrate that strings are mutable? Does it demonstrate that lists are mutable?
MW	Use list comprehension to take a list of numbers, and return a list of squares of those numbers, but only of those numbers which were even.
MW	Use list comprehension to create a list containing all names in the list `names` that are at least 3 characters long. Also use list comprehension to create a list of integers that indicate, for each name in the original `names`, how many characters it contains.

Note    With list comprehension a _lot_ can be done in a single, compact line of code, and with great power comes great responsibility. Compact code is never in itself a goal; code must be _readable_ above all else. Therefore, use list comprehension only if you think this makes the code more readable than e.g. a multi-line `for`-loop. This is only the case, typically, if the modification or filtering condition you want to apply is sufficiently simple. In general: don't write 'clever' code; write _clear_ code.

MW	Redo the previous two exercises _without_ list comprehension, by using an ordinary multi-line for-loop. Which version do you find more readable?
MW  Use list comprehension to write a function that takes two lists, `source` and `filter`, and returns a new list that is exactly like `source` but with all elements removed that are not in `filter`. Test at least an example where the resulting list should be equivalent to the filter, and an example where it should not.
***Replace the foregoing by exercises to implement union, intersection, complement?



Title	More practice with lists and loops (also `index`, `range`)

***Also introduce sort and sorted already (helps explain in-place vs. mutate, too).

MW	Define three functions, each of which takes a list of numbers (e.g., the outcomes of an experiment) and returns a number. The first returns the sum of all elements. The second uses the summation function to compute and returns the list's average. The third uses the averaging function to compute and return the list's standard deviation. For the latter, you can do `import math` to use the `math.sqrt` function.
MW	Write a function that takes a list of words like `words = ['the', 'dog', 'is', 'in', 'the', 'garden']`, takes the length of each word, and prints the total sum of word lengths. Do you get the same number as `len('the dog is in the garden')`? Why (not)? What about `len(words)`?
MW	Write a function `index_in_string` that takes a string and a character, and returns the index of the first occurrence of that character in the string. For instance, `index_in_string('david', 'v')` returns `2`. Explain why `index_in_string` can be seen as the inverse of the square brackets slicing notation for retrieving a character by index.
MW	Write a function `index_in_list` that does the same, but for a list instead of a string. Could you reuse any of the previous code?
***Add a remark about frustration here.
MW  Lists and strings in fact already come with a method `index`, which is called like this: `'david'.index('v')` or `[6, 4, 8, 6].index(8)`. Does this method behave the same as your own implementation from the foregoing exercises? What happens if the string or list does not contain the element you request the index for? Which index is returned if it contains the requested element multiple times? After testing this empirically, call for `help` on the `index` method to confirm your findings.

Note    Lists and strings have a method **index**, which you can use to find the (first) index of an element in the list, provided it exists.

TP3	Remember your function `day_number_to_name` from earlier, that converts an integer number 1 to 7 to the name of a day? Now use the list method `index` to write the inverse function `day_name_to_number` which is given a day name, and returns its integer representation.
TP3	Write a function `month_to_ndays` which takes the name of a month, and returns the number of days in the month. Ignore leap years. It can be helpful to define two lists, one with the month names and one with the corresponding numbers of days. (Later we will learn about _dictionaries_, which would streamline this a bit further.)
MW	Write a function `find_index_of_largest` that finds and returns the _index_ of the largest element in a list (in mathematical terms this would be an _argmax_ function). You can do this without any explicit looping, namely by using the built-in functions `max` and the list method `index`. (Optional: Consider why this is not the most _computationally efficient_ way, e.g., imagine you had a list of millions of numbers.) What if you give your function a list of strings? What if you give it not a list, but a single string?

MW	Write a function that takes a string, namely an English sentence, and loops through the characters of the string, ultimately returning the total number of _words_ in the sentence. Hint: Generally speaking, in written English, how do you know a new word is beginning?

***Not super helpful   Note	When you are asked to write a program, define a function, etc., sometimes a function name is given, but often this decision will be left to you. Likewise, you often need to decide whether to create a new file or add the new function to an existing file. Always choose a logical place, and a meaningful, transparent name, favoring clarity over brevity.

MW	Write a function that takes a string and returns a new string where all vowels have been replaced by the character _y_. Could you change the function to modify the original string _in-place_, instead of returning a changed copy? What if you give it a list of characters instead of a string, e.g., `vowels_to_y(['b', 'a', 'n', 'a', 'n', 'a'])`?

Subtitle    Looping over consecutive numbers with `range`

MW	It is often convenient to loop over consecutive numbers (0, 1, 2, 3, ...). One way to achieve this is to create a list of numbers and loop over those list elements just as we did before, e.g., `for n in [0, 1, 2, 3]:`. Use this technique to print each number from 0 to 9. To understand a downside of this technique, consider printing the numbers up to 999 in the same way (but don't).
MW	A more convenient way to loop over consecutive numbers is to use `range`, e.g., `for i in range(10):` loops over all integers from 0 to 9. Try this, and see how easily it scales up to larger ranges.

Note    To loop over a **range** of consecutive integers from 0 to some integer `n`, use `range(n)`. We will learn more about `range` later, as it is a lot more flexible/powerful than simply 'integers from 0 to _n_'.

MW  For a list like `words` from above, what does looping over `range(len(words))` achieve? Use it to print each index (0, 1, 2, ...) next to the corresponding element in the list (`0 the`, `1 dog`, `2 is`, etc.). (Later we will learn a slightly more Pythonic way to achieve this, using `enumerate`.)
MW  What happens if in the above `range` construction, you forget the `len`, so it reads `for i in range(words)`? This type of mistake is easily made, so it is helpful if you can recognize it. And what happens if you accidentally do `for i in range(len(words - 1))`? (Do you see the mistake?)
MW  Use `range` to iterate over indices of the list `words`, in a way that lets you print _pairs_ of consecutive words, or **bigrams** (`the dog`, `dog is`, `is in`, etc.). What should be the upper bound of your range?

Subtitle    Further practice with lists and loops

MW	The code below implements a simple tokenizer, that takes a text and returns a list of words. (Later we will learn more convenient methods for this, but the code below illustrates a useful pattern.) Try to understand how the function works and apply it to a number of sentences. Can you improve the tokenizer to ensure that punctuation marks are treated as separate tokens? For example, `tokenize('Hello, world!')` should return `['Hello', ',', 'world', '!']`. Subsequently, can you think of some other shortcomings and possible fixes?\n```
def tokenize(sentence):
    tokens = ['']
    for char in sentence:
        if char == ' ':
            tokens.append('')
        else:
            tokens[-1] += char
    return tokens
```
MW	Define a function that takes a string (an English sentence) and first uses your `tokenize` function to obtain a list of tokens, and then loops through the resulting tokens to collect all _bigrams_. Your function should return a list of all bigrams. You can represent each bigram as a list containing two words (or a tuple/pair, but we will learn about that later), e.g., `['the', 'apple']` for the bigram _the apple_. The returned list is, therefore, a list of lists, each inner list containing two strings.
MW	Create another function to collect not bigrams but _trigrams_, i.e., sequences of three consecutive words.
MW   Two more conceptual questions (no programming required): \n 1. Currently your `bigrams` and `trigrams` function each take an untokenized string as parameter and call the `tokenizer` function on it. This means that, if we need both bigrams and trigrams for our research, we would be tokenizing each text _twice_! How could we restructure the code to avoid this redundancy? \n 2. Can you think of a way to combine the `bigrams` and `trigrams` functions into a single `ngrams` function (maybe taking an additional integer argument `n`), to avoid code repetition?

MW  In the following example, how come the list `cities` doesn't change?\n```
cities = ['amsterdam', 'rotterdam', 'leiden', 'gouda', 'eindhoven']
for city in cities:
    city.capitalize()

print(cities)
```
MW  What about now? (First formulate your prediction, then test it.)\n```
cities = ['amsterdam', 'rotterdam', 'leiden', 'gouda', 'eindhoven']
for city in cities:
    city = city.capitalize()

print(cities)
```
MW  If the previous code did not change the list `cities`, modify the code so that it does. Does your modification actually change the original list in-place, or create a new, modified copy (re-assigned to the old variable)?
MW	Earlier we saw that if-clauses can be nested. What about for-clauses? Write a function (and think of an appropriate name) that loops over the `cities` list from earlier (`for city1 in cities:`), and nested within that loop, loops over the same list again (`for city2 in cities:`). In the body of the inner loop, print the two names stored in `city1` and `city2`, concatenated with a dash in between. Can you predict what will be printed? Try it, and make sure you understand what's happening.
MW	(It will likely be helpful to print a separator in between exercises (e.g., `print('---------')`), or you'll loose track of where each printed text originates from!) In the previous exercise, why did the inner loop use a different variable from the outer loop, namely `city2` and `city1`, respectively? Do you understand the output of the following variant?\n```
for city in cities:
    for city in cities:
        print(city)
```
MW  Use nested loops and if-statements to print all pairs of cities where the first city name starts with a vowel and the second with a consonant. Looking at the city names, can you predict how many lines will be printed?
MW  Write a function `chain` that takes a list of lists, and chains all lists into a single list. For example, chaining `[[1, 2], [3, 4, 5], [6, 7]]` will result in `[1, 2, 3, 4, 5, 6, 7]`.

MW  Remember your random sentence generator from before? Use the same lists of words as before (determiners, nouns, intransitive verbs, transitive verbs), but now, instead of returning one random sentence, write a function that *prints* _all possible sentences_, one after the other. This will require many nested loops.
MW  If your sentence generator had actually implemented a full human grammar, would the previous function ever terminate? (Should it?)
TP3	The four compass points can be abbreviated by single-letter strings as `'N'`, `'E'`, `'S'`, and `'W'`. Write a function `turn_clockwise` that takes one of these four compass point strings as an argument, and returns the next compass point in the clockwise direction.
MW	Explain the difference between `type(turn_clockwise)` and `type(turn_clockwise('N'))`.
TP3	Also define an analogous function `turn_counterclockwise`. Should `turn_counterclockwise(turn_clockwise('N')) == 'N'` evaluate to `True`? Does it?
MW	If you haven't done so already, perhaps you can streamline the functions `turn_clockwise` and `turn_counterclockwise` by storing the four compass points in a list. To simplify the function definitions, both the list method `index` and the modulo operator `%` can be useful here.
MW	Extend your clockwise and counterclockwise functions to deal with four diagonal directions (such as North-East `NE` and South-West `SW`). If this is difficult or requires a lot of manual typing, it means your functions could probably have been implemented in a smarter, more concise way...


Title   Functions, parameters and arguments

MW  Without looking up a definition, try to explain in your own words what a _function_ is in programming (specifically Python). The current section aims to increase your understanding of this central concept.
MW  You have already seen two ways of passing arguments into a function: by simply passing in a value or variable, or by using an equals sign such as `sep='-'` in `print('apple', sep='-')`. Without looking it up, try to formulate a hypothesis about the difference between the two ways of specifying arguments, and when you should and shouldn't use `=`. (The truth is difficult to guess from the exercises so far, but by formulating a specific hypothesis now, you will be better able to grasp the actual explanation later in this section.)
MW  Define again the simple function `print_spam` we used in earlier sections (with no parameters, simply printing `spam`). Explain (for instance using `type`) what the difference is between `print_spam` and `print_spam()`.
MW	What happens if you assign a function to a variable, e.g., `shout_nonsense = print_spam`? Can you call the function using the new variable, instead of the original name?
TP2	Write a function `do_twice` that takes a function `func` as a parameter and calls that function twice. Having done that, calling `do_twice(print_spam)` should execute `print_spam()` twice. What happens if, instead, you accidentally do `do_twice(print_spam())`? Why?

Note    In Python, a function is _not_ a piece of code, and calling a function is _not_ a matter of sending the interpreter to the lines in your file where the function is defined. Rather, in Python **functions are objects in their own right**. A `def`-clause is an instruction to the Python interpreter to create such an object and assign it to a variable with the same name as the function. In Python tutorials you'll often read that 'functions in Python are first-class citizens', to mean exactly this. Accordingly, functions, just like the other objects we have worked with so far (strings, ints, lists), can be (re)assigned to variables and passed around as arguments.

TP2	Define a function `do_twice_with_argument` that takes two arguments, a function `func` and a value `arg`, and calls the function twice with that argument. The command `do_twice_with_argument(print, 'test')` should result in `test` being printed twice.
MW  Can you predict the outcome of `do_twice_with_argument(do_twice, print_spam)`? Test your prediction and make sure you understand what is going on. (In between these exercises, it is advisable to print an empty line to keep track of which output comes from which exercise.)
MW  Generalize the previous functions to `do_multiple` and `do_multiple_with_argument`, by adding a parameter `n` to each, with the effect that the function `func` will be executed `n` times (`range` can be useful here).
MW  As objects, functions carry some information along with them, such as the `__doc__` attribute containing the function's docstring (shown when `help` is called on the function, as we did earlier), and `__name__` storing the function's name. Try `print(print_spam.__name__)`. (Can you explain what happens if you do `print(print_spam().__name__)` instead?)
MW  What happens to the `__name__` attribute of a function if you assign a function to a new variable, and retrieve the `__name__` property from that new variable?
MW  Function objects also offer various methods (similar to strings having methods like `upper` and `capitalize`, and lists having `append` and `index`). Calling a function like `print('apple')` is in fact shorthand for invoking the `__call__` method of the function object, i.e., `print.__call__('apple')`. Verify that this is the case, and also test it for a couple of functions you yourself defined.

MW  Recall that ctrl+click (or cmd+click) on a variable brings you to the place where a value was assigned to it. Try this in the example below, on the variable `var` in the definition body. Where, according to this method, is this variable assigned a value?\n```
def example_function(var):
    print('blablabla')
    print('1234567')    # just some filler material
    print(var)
```

Note    It may seem like we use 'argument' and 'parameter' interchangeably, but there is a subtle difference. When you _define_ a function, you specify its **parameters** in the header of the `def`-clause. When you _call_ a function, you can provide it with **arguments**. The called function will use the provided arguments as values for its parameters. But how does Python know which arguments are meant to set which parameters? The following exercises teach you more about that.

Subtitle    Positional arguments and keyword arguments

MW  When calling a function, you have seen that sometimes arguments are simply given as a value, and sometimes as a `parameter=value` expression, a so-called **keyword argument** (e.g., `print('apple', end='')` uses both). In Python, you can often choose how to pass values as arguments to a function: the value on its own, or as a keyword argument `parameter=value`. Look carefully at the following code, predict the outcomes and test your predictions.\n```
def print_diff(a, b):
    print(a - b)

print_diff(5, 2)
print_diff(a=5, b=2)
print_diff(b=2, a=5)
print_diff(2, 5)
print_diff(a=2, b=5)
print_diff(b=5, a=2)
```
MW  Arguments passed _without_ the parameter name are also called **positional arguments**. Given the previous example, do you understand why?
MW  Given your answer to the preceding question, try to predict which of the following works fine, and which one crashes. Test your prediction and make sure you understand what is going on.\n```
print_diff(5, b=2)
print_diff(2, a=5)
```
MW  Although positional and keyword arguments can be mixed, no positional argument can _follow_ a keyword argument. Try `print_diff(a=5, 2)` to see what error you get. Here is an intuitive explanation: argument order (for positional arguments) is determined by counting left-to-right, so if a keyword argument indicates 'order doesn't matter here', then the order of any arguments to the right of it cannot be relied upon either, hence any arguments to the right of it must also be given as keyword arguments.

MW  Although typically one can choose whether to call a function with positional or keyword arguments or both, sometimes programmers may decide that certain (or even all) arguments _must_ be passed as keyword arguments. This is the case, for instance, for functions that permit any number of positional arguments, such as the built-in function `print`, e.g., `print('apple', 'pear', 'banana')` prints all three. Explain why it follows from this feature of `print`, that the additional `sep` and `end` parameters of `print` must _always_ be given as keyword arguments, by considering what happens if you don't:\n```
print('apple', 'pear', 'banana', sep='-', end='.')
print()  # print newline for clarity
print('apple', 'pear', 'banana', '-', '.')
```
MW  Another reason why programmers sometimes choose to enforce the use of keyword arguments is _explicitness_. For instance, in the Seaborn library for creating plots, all parameters of a function like `scatterplot` must be specified with keyword arguments (e.g., `scatterplot(data=tweets, x='date', y='sentiment')`). Explain in what sense keyword arguments are more explicit than positional arguments.
MW  For the sake of completeness, the way to let functions take any number of positional arguments (like `print`) and/or enforce the use of keywords for explicitness (like `scatterplot`), is through the use of an asterisked parameter `*` in the function definition header, which essentially 'eats up' any positional arguments given when the function is called; as a consequence (consider why this follows), any parameters occurring after the asterisked parameter cannot be positional, hence _must_ be specified with keywords. Try the following to better understand this:\n```
def some_weird_function(*a, b, c):
    print('a:', a)
    print('b:', b)
    print('c:', c)

# some_weird_function(1, 2, 3)     # will complain that `b` and `c` are not given values, as all positional arguments are eaten up by `*a`.
some_weird_function(1, b=2, c=3)    # this one works fine
some_weird_function(1, 2, 3, 4, b=5, c=6)   # this also works fine
```
MW  Reflect on the role of the asterisk in the definition of the built-in `print` function:\n```
def print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False):
```

Subtitle    Parameters with default values

MW  We have learned that the syntax `parameter=value` is used in function calls to pass values to the function as keyword arguments. Does it follow that the same syntax in the above definition of `print` shows that `end`, `file` and `flush` are keyword arguments?

Note  When you _define_ a function, you can specify **default values** for some or all of the parameters, using `parameter=value` syntax in the header of the function definition (not to be confused with the same `parameter=value` syntax used when _calling_ a function, to specify keyword arguments!). Parameters with default values can be omitted from the function call, in which case the default value is used.

MW  Explain how the foregoing is illustrated by the following code:\n```
def multiply_and_add(a, b, c=1):
    print(a * b + c)

multiply_and_add(2, 3)
multiply_and_add(2, 3, 4)
```
MW  Explain how by specifying or omitting default values in your function _definition_, you can effectively make certain arguments **mandatory** and others **optional** when calling the function.
MW  Define a function `subtract` with three parameters: two mandatory numbers `a` and `b`, and one optional boolean `absolute`, where the latter has default value `False`. The call `subtract(3, 5)` should evaluate simply to the difference `3 - 5`, i.e., `-2`. The call `subtract(3, 5, True)` should evaluate instead to the absolute (positive) value of the difference, i.e., `2`.
MW  Look up the function `tokenize` from the previous section, and if needed copy the code to your current working file. Note that it effectively removes spaces from the input text, returning only the tokens. This makes it harder to reconstruct the original text by re-concatenating all the tokens, which in some cases might be a desirable functionality. For this reason, add an optional parameter to the function, `keep_spaces` with default value `False`. When the default is overriden (i.e., when the function is called with the additional argument `True`), the returned tokens should have their spaces still attached. For example, `tokenize('The cat sleeps.', True)` should evaluate to `['The ', 'cat ', 'sleeps', '.']` (note the spaces). Also verify that omitting the optional argument results in the original behavior.

Note  While the syntax of specifying default values (`parameter=value`) looks similar to the syntax of keyword arguments explained at the start of this section, the two notions -- default value and keyword argument -- are conceptually _very_ different. Default values are an aspect of function _definitions_, while keyword arguments are an aspect of function _calls_. Whether a parameter is given a default value when _defining_ the function, has nothing directly to do with whether you should use positional or keyword arguments when _calling_ the function.

MW  To illustrate the preceding explanation, verify that the optional arguments of the `subtract` and `tokenize` functions from above can be passed both as a positional argument and as a keyword argument.
MW  Try to predict the printed output of the following function calls, and test your understanding:\n- `multiply_and_add(2, 3, 5)` \n- `multiply_and_add(a=2, b=3, c=5)` \n- `multiply_and_add(c=5, a=2, b=3)` \n- `multiply_and_add(2, b=3)` \n- `multiply_and_add(2, b=3, c=5)` \n- `multiply_and_add(a=2, b=3)` \n- `multiply_and_add(b=3, a=2)`
MW  In function definitions, parameters without default values should come before parameters that have defaults. Try this with an example that violates the rule, e.g., `def my_function(a, b=1, c): ...`.
MW  Given the preceding rule that parameters with defaults should come before parameters without defaults in the function definition, how come the function call `multiply_and_add(c=5, a=2, b=3)` is allowed, i.e., how come `c`, which has a default value, can nevertheless come before `a` and `b` here?
AMY Default values are created only once, at the start, when the function is defined; _not_ each time the function is called. This can lead to puzzling behavior when you use a _mutable_ object like a list as default argument: since it is mutable, it can be changed, thereby causing the default value to change. For example, consider the function below and what it is _supposed_ to do, according to the docstring, if no list argument is given. Explain what goes wrong, taking into account the mutability of the default argument.\n```
def append_to(element, l=[]):       # note: the docstring is a lie
    """
    Appends the element to the provided list, returning it, or to an empty list if none was provided (resulting in [element]).
    """
    l.append(element)
    return l

print(append_to('cat', ['dog', 'horse']))
print(append_to('cat'))
print(append_to('cat', ['mouse']))
print(append_to('cat'))
```
MW  When entering the above code in PyCharm, the editor will likely immediately warn you that 'Default argument value is mutable'. PyCharm may even offer you to automatically fix it, which will result in code like the following. Try to understand how this fix works, i.e., how it avoids the problem illustrated in the previous exercise:\n```
def append_to2(element, l=None):
    """
    Appends the element to the provided list, returning it, or to an empty list if none was provided (resulting in [element]).
    """
    if l is None:       # Equivalently, replacing the whole if-clause:  l = l or []
        l = []
    l.append(element)
    return l

print(append_to2('cat', ['dog', 'horse']))
print(append_to2('cat'))
print(append_to2('cat', ['mouse']))
print(append_to2('cat'))
```

Note   The fact that a function's default values are created only once, when the function is defined, reflects that (in Python) functions are not pieces of code but objects ('first-class citizens'), created only once, when the interpreter reads the definition to create the function object (including its default values). Calling a function does not execute the `def`-clause anew, but rather call a designated method on the function object that has already been constructed (and its default values already set).

MW  We have already seen that functions, as objects in their own right, have various properties that you can inspect, such as `__doc__` and `__name__`. Another property of functions is `__defaults__` (not for built-in functions though). Use this to inspect the default values of some of the functions defined above, e.g., `print(append_to.__defaults__)` and `print(multiply_and_add.__defaults__)`. For the problematic function `append_to` from above, compare its `__defaults__` before and after a call `append_to('cat')`.

MW  In the previous section you defined `turn_clockwise` and `turn_counterclockwise`, to take directions like `'N'`, `'NW'`, and `'SE'` and return a new direction after turning. (Copy these to your current working file if needed.) Extend their functionality with an optional argument `n_turns` that has `1` as its default value, representing the number of 'turn steps' to take.

MW  This section introduced some tricky and important concepts, so it is important that you try to formulate your own summary. What is the difference between arguments and parameters? What is their relation, i.e., what happens when you call a function with arguments? Can you summarize what keyword arguments and positional arguments are? What are the rules for mixing positional and keyword arguments in your function call? How do default values for function parameters work? Is there a rule that constrains which parameters can and cannot have default values? Why is it risky to specify mutable objects as defaults?


Title   Encapsulation and variable scope

MW	Earlier we saw what happens if you call a function before defining it. Try this again.
MW  The foregoing exercise should have resulted in an error. A Python program will terminate when an error is encountered (or more accurately: when an exception is _raised_ and not _caught_ somewhere higher up). Nevertheless, you may occasionally have seen noticed printed output appearing _after_ (i.e., below) an error message. Try to reproduce this oddity: Write some code that prints a bunch of stuff and then, at the end, does something illegal (e.g., reference a function before it is defined). Run it to verify that the error message can (at least sometimes) appear in the output before (i.e., above) the printed message. (If this never happens, perhaps your system is configured in a way that prevents this.)

Note    The command `print` sends content to the **standard output stream**, while error messages go through a separate **error stream**. Each stream is 'buffered', meaning messages are first stored in a 'buffer' that is then, periodically, 'flushed' onto the Run output window on your screen -- only _then_ do you see the output. It can happen that the error buffer is flushed _before_ the standard output buffer, and thereby cause an error message to appear _before_ certain printed messages, even if the error was in fact encountered a few nanoseconds _after_ the last `print` command. This is a technicality, but knowing about this can prevent confusion about the (apparent) source of an error.

MW  If in the previous exercise you were able to let an error message appear before the printed messages, now add `flush=True` as an extra argument to your `print` statements (or at least the last one before the error) and try again. The error message should now consistently appear last (i.e., at the bottom of your output). This is because `flush=True` tells Python to flush the standard output buffer immediately, i.e., as soon as the `print` command is given. Although you won't normally need to use `flush=True`, you can use it in the following exercises if you find the order of print and error messages in your output confusing.
MW  Define a function `invert` that takes a string and returns the inverted string, and then define a function `print_inverted` that takes a string and (inside its definition) calls the `invert` function to invert it, and finally prints the result (with `flush=True` for clarity). The point here is that we have one function (`print_inverted`) that, in its definition body, references another (`invert`). Does the order in which the two functions are defined matter? Formulate a prediction, then test it. Try to form a hypothesis about why this might be.
MW  Test and (if needed) refine your hypothesis about the order of function definitions and function calls, by comparing the following two programs. For this, make sure that you try each version _on its own_, for instance by placing each in a separate file, or by commenting-out one version when you run the other and vice versa.\n```
# The first program:

def print_sum(a, b):
    print(add_numbers(a, b), flush=True)

def add_numbers(a, b):
    return a + b

print_sum(1, 3)

# The second program (make sure you try the two programs separately):

def print_sum(a, b):
    print(add_numbers(a, b), flush=True)

print_sum(1, 3)

def add_numbers(a, b):
    return a + b
```

Note	A Python script is interpreted **top-to-bottom**. To understand this, it is important to recall from the previous section that functions are _not_ pieces of code, and calling a function does _not_ mean 'sending the interpreter to the line where the function is defined'. Rather, functions are objects, that are created and stored in working memory when the interpreter (going top-to-bottom) encounters a `def`-clause, and to call a function is to invoke a method of the function object that is in working memory (i.e., top-to-bottom interpretation is not interrupted to 'go to the line where the function is defined').

MW  The difference between defining and calling a function explains why in the body of one function definition, you can reference some other function even if that function's definition comes later in the file, as long as the containing function isn't _called_ before the referenced function is defined. In light of this, review your understanding of the preceding two exercises.
TP3	Write a function `time_to_secs` that takes three arguments -- hours, minutes, seconds -- and converts the time these jointly represent to a total number of seconds, which it returns as output. If necessary extend `time_to_secs` so that it can cope with real (i.e., non-integer, or floating point) values as inputs. It should always return an integer number of seconds ('truncated', or rounded down).
TP3	Write three functions that are the partial _inverses_ of `time_to_secs`: \n 1. `hours_in` returns the whole integer number of hours represented by a total number of seconds; \n 2. `leftover_minutes_in` returns the whole integer number of _left over_ minutes in a total number of seconds once the hours have been taken out; \n 3. `leftover_seconds_in` returns the left over seconds in a total number of seconds, once the hours and minutes have been taken out. \n\n You may assume that the total number of seconds passed to these functions is an integer.
MW  Write a single function that is the inverse of `time_to_secs`. It should use the preceding three auxiliary functions to obtain hours, minutes and seconds, and return these values together as a _tuple_ like this (we will learn about tuples later): `return hours, minutes, seconds`. Does the order matter in which the various function definitions appear in your file? What about the position of the function calls?
MW  In an earlier section you defined functions `bigrams` and `trigrams`. (Copy these to your current code file if necessary, along with `tokenize` on which they rely.) To refresh your memory, also define a function `quadrigrams`, for sequences of four words. The definitions of these functions likely contain considerable overlap. Avoid this by defining a function `ngrams` that takes a text and a number `n`, returning a list of n-grams in the text (bigrams if `n == 2`, trigrams if `n == 3`, etc.); redefine the original functions `bigrams`, `trigrams` and `quadrigrams` as, essentially, shortcuts for `ngrams`.

Note	Streamlining your code is called **refactoring**, one aspect of which is dividing your code into functions, sometimes called **chunking**. One rule of thumb for refactoring/chunking is **Don't Repeat Yourself** (DRY), i.e., consider defining a function when you find you are repeating chunks of code. Another is the **Single Level of Abstraction Principle** (SLAP): a function should do a single thing at a single level of abstraction. The latter is related to the ideal of **Separation of Concerns** (SoC), e.g., when you're defining an `ngrams` function, you shouldn't need to worry about how to tokenize a text, and vice versa).

MW  Can you think of some reasons why it is (often) a good idea to try to avoid repeated chunks of code, i.e., why the DRY principle is a useful guideline?
***In the following exercise, also update the bigrams, trigrams etc. functions?
MW  Our client requests that we add a boolean parameter `as_strings` to the function `ngrams`, with default value `False`. If this boolean is set to `True`, the n-grams in the returned list should be represented as single strings, not lists of strings (e.g., `'the cat eats'` instead of `['the', 'cat', 'eats']` to represent a trigram). Make the required change. What is an advantage of having refactored your code in terms of the `ngrams` function?
Mw  Remove your functions `ngrams` and `tokenize` from your current working file, and move them to a new, empty Python file you call `text_utils.py` (in the same directory as your current working file). We will be importing `text_utils.py` as a module, so make sure it contains only function definitions, no function calls. Having made this change, your `bigrams`, `trigrams` and `quadrigrams` functions (which remained in your main working file) will no longer work (test this!), as after the above refactoring they rely on `ngrams` (which is no longer here). To restore their functionality, place `import text_utils` (note without the `.py`) at the top of your current working file, and replace every reference to `ngrams` by a relative reference to `text_utils.ngrams`. Verify that everything now works properly again. Future sections will likewise rely on `import text_utils` for easy access to `ngrams` and `tokenize` (or else we'd have to duplicate the code into each new file).

Note    The `import` keyword lets us use not only existing modules (such as `random` or `math`), but also reuse our own Python files. It is generally advisable that files that are imported only _define_ functions, not _call_ them, lest the import has 'side effects'. We will learn more about `import` and modules later.

MW  Define a function `filter_by_twos` that takes a list, and returns a new list containing every second element (so given `['a', 'b', 'c', 'd', 'e', 'f']` it will return `['b', 'd', 'f']`). Define another function `filter_by_threes` that does the same but for every _third_ element (for the same example, it will return `['c', 'f']`). There is likely some code repetition (or a lot, depending on how concise your code is). Define a generalized function `filter_by_n` that takes an additional argument `n` and returns a list with every `n`th element, then redefine your original functions in terms of this, as shortcuts.
MW  In section 10 you defined `turn_clockwise` and `turn_counterclockwise`, taking a string representation of a direction (`N`, `E`, `S`, `W`) and returning a string representation of the new direction after turning. (Copy these to your current file if needed; we won't use them later so no need to put them in a separate module.) There is likely considerably overlap between the two functions. If so, try to minimize overlap, for instance by defining a generalized function `turn` that can turn in both directions depending on whether a given integer argument is negative or positive.


Subtitle    Encapsulation and variable scope

MW  Another reason for chunking your code into functions is **encapsulation**: variables assigned inside a function, are not accessible outside it. This keeps the number of accessible variables at a given place in your code smaller, which helps prevent certain types of programming errors. Explain how the following code illustrates encapsulation. (Remember we add `flush=True` to a print statement to flush the print buffer directly, in order for printed output and error messages to appear in order of execution.)\n```
def some_function():
    b = 123
    print('inside the function, b =', b, flush=True)

some_function()
print('outside the function, after calling the function, b =', b)
```
MW  In the previous example, what happens if you assign something to `b` also in the global scope, before the function definition? For instance, add  `b = 789` (a different value) above the definition of `my_little_function`.
MW  And what happens if you now remove the line `b = 123` from the function (while keeping `b = 789` above the function definition)? What gets printed? This and the foregoing exercises show that there is some kind of asymmetry between local scope and global scope with regard to variable accessibility. Try to formulate in your own words what this asymmetry is (further below it will be stated in more precise terms).
MW  Unlike `def`-clauses (function definitions), `if`-clauses do not create a local scope, i.e., do not encapsulate the variables assigned within it. Explain how the following example demonstrates this:\n```
if 1 + 1 == 2:
    x = 'test'
    print('inside the if:', x)

print('outside the if:', x)
```
MW  Does the following example demonstrate that `for`-clauses likewise do not encapsulate their variables?\n```
for x in [1, 2, 3]:
    print('inside the for:', x)

print('outside the for:', x)
```
MW  Does the following code show that `if`-clauses do create a local scope after all? Or does it show something else?\n```
if 1 + 1 == 3:      # Notice the 3!
    x = 'test'
    print('inside:', x)

print('outside:', x)
```
MW  What about an `if`-`elif`-`else` compound clause? Are variables assigned in the initial `if`-clause accessible in subsequent `elif` and `else` clauses? (Does the question even make sense?)
MW  The built-in functions `locals` and `globals` give you a _dictionary_ containing all local/global variables and their values. We will learn about dictionaries later, but you can already try them out by running the code below. Note that among the global variables are many 'dunder' (double underscore) variables like `__name__` that Python relies upon for bookkeeping, so you may need to scroll to the right to see the variables you yourself assigned.\n```
a = 3
b = 4

def my_function(c):
    d = 6
    e = 7
    print('inside my_function, locals = ', locals())
    print('inside my_function, globals =', globals())

my_function(5)
```
MW  In the above example, the local scope also contains a variable `c`. Where does it come from, i.e., where is it assigned its value? (Recall the ctrl+click exercise of the previous section.)
MW  Modify the above example to print `globals()` and `locals()` also from _outside_ the function definition, e.g., put the print statements below the function call. What does this demonstrate?

Note  When Python enters a local scope (e.g., function definition), `locals()` is initially empty. If a variable is _assigned_ a value inside a local scope (e.g., inside a function definition), this variable+value will be stored in `locals()`, not `globals()`. When a variable's value is _retrieved_ inside a local scope, Python will first try to find it in the `locals()` dictionary, and only if it does not find the variable there it will look in `globals()`. (Actually there are two other 'namespaces' in which Python will search for a variable: Python indeed first looks in the local scope, but then it checks the immediately 'enclosing scope' (e.g., if the function is itself contained in a function or class), before considering the global scope, and finally it looks among the `__builtins__`, for built-in functions such as `len` and `print`.)

MW  We have seen that variables defined inside functions can have the same name of an existing variable from outside the function, without the latter being affected. Explain exactly how this can be.
MW  For every place in the following code where the value of a variable is retrieved, determine the place where its value at that point was assigned. Take into account mutability: mutable objects like lists can be changed _without_ this involving reassigning the variable. While you're at it, a good exercise is to try to predict the exact output of this program.\n```
students = ['ann', 'beth', 'gemma']
more_students = ['dale', 'ebba']
message = 'Hello!'

def print_students(students):
    students = [name.capitalize() for name in students]
    for student in students:
        print(message, student)

students[1] = 'elisabeth'
all_students = students + more_students
all_students.append('philip')
print_students(all_students)

if len(all_students) > 3:
    message += ' Nice crowd!'
    print(message, flush=True)
```

MW  The above 'something to keep in mind' left out an important detail: when a variable is assigned a value _anywhere_ in the local scope, then that variable becomes _strictly local_ to that scope, meaning Python will _only_ try to find it in `locals()`, and _never_ look for that variable in`globals()`, _even if the lookup in locals() fails_. This can cause surprising behavior. Try to predict what the following code does, test your prediction, and reconcile your findings with the rules for encapsulation explained so far.\n```
a = 5

def erroneous_function():
    print(a)
    a = 8

erroneous_function()
```
AMY  What might one naively expect the following function to print? Explain why this expectation is wrong, namely, why the following gives an error:\n```
b = 10

def bad_function():
    b += 3
    print(b)

bad_function()
```
MW  The foregoing exercises reveal that a variable inside a function is either local or global, _never_ local on some lines (in the function) and global on other lines (in that same function). Can you think of a possible benefit of this all-or-nothing behavior?
MW  Try to predict the entire printed output of the following program, and test your prediction:\n```
x = 6

print(x)

def first_function(x):
    print(x)

def second_function():
    print(x)

def third_function(y):
    x = y - 3
    print(x)

print(x)
first_function(3)
print(x)
second_function()
print(x)
third_function(x)
print(x)
```
MW  Does the foregoing mean that there is _no_ way to have a function assign a value to a global variable? Well, you may not ever need this, but there is a way: for a given variable `x`, typing `global x` at the top of the body of a function definition will make sure that `x` in that function serves as a global variable, even if you assign something to `x` in that function later (result: it will assign to a global variable). Play around with this if you like. But the more important take-away of this section is how Python governs variable scope (hence, why something like the `global` keyword would be needed in the first place) -- try to summarize that.


***Probably superfluous here: Note	_Code is read much more often than it is written._ For this reason, when 'streamlining' your code, the goal is never brevity in and of itself. The goal, rather, is to improve the *readability* of your code.
*** MW  Speaking of readability, did you remember to add docstrings to all your functions?


Title	Dictionary basics

MW	Run the code below to construct `name_to_id`, a mapping or _dictionary_ from fictional student names (the keys) to student IDs (the values). Then inspect the object you created by printing `name_to_id`, as well as `type(name_to_id)`.\n```
name_to_id = {'Alf': '136124', 'Beth': '008623', 'Chris': '014212', 'Dave': '9123785', 'Esra': '978123'}
```
MW	You can look up a particular value in the dictionary by providing it with a key in square brackets (like list index notation). Look up the student IDs (values) of Alf and Chris (keys), and print them.
MW	What happens if you try to look up the student ID (value) of a student whose name is not a key in the dictionary? What happens if you forget the quotation marks around the key string you're looking up?
MW	Does a dictionary have a length, just like lists and strings? Can you create an empty dictionary?
MW  Can you use the keyword `in`, just as with lists, to check if an element is contained in a dictionary? If so, does `in` look at the keys or the values, or both?
MW  Does a dictionary support integer indexing just like lists and strings, e.g., can you select the third item (index 2) in the above dictionary by doing `name_to_id[2]`?
MW  What if we have a dictionary with integers as keys instead of strings, like `{1: 'hi', 2: 'hello', 3: 'bye', 4: 'tata'}`? Can we now access an element by its index (or is this a misleading way to put it)?

Note   A **dictionary** is Python's main datastructure for storing a mapping, from _keys_ to _values_. Both keys and values in a dictionary can be various types of objects, e.g., integers, floats, strings, functions, and more complex objects. However, not every type of object can be used as a dictionary key; keys must have a special property of being **hashable**, which is, roughly, that the object provides a `hash` method that generates a string code that (virtually) uniquely represents the object. It is by these hash strings that the items in a dictionary are stored and retrieved.

MW	What happens if you define a dictionary by specifying key-value pairs (like `{'Alf': '36124', 'Beth': '008623'}`) but using equals signs `=` instead of the colons `:` to connect keys and values? Do you see why this is quite an easy-to-make syntax mistake?
MW  Try to construct an integer-to-integer dictionary, say, from numbers representing an age (in years) to the number of (hypothetical) students that have that age. Construct a string-to-integer dictionary that could be a (small) example of a mapping from words to their counts in some (hypothetical) corpus. Construct a string-to-list dictionary that maps the name of a hypothetical course (say, `'semantics'`, `'syntax'`, `'python'`) to a list of students taking that course. Lastly, what happens if you try to construct a list-to-integer dictionary that, say, maps a list of numbers to its average? Why?
MW  Can a single dictionary mix multiple types (e.g., integers, floats, strings) as values, and/or multiple types as keys?
MW  Do you expect dictionaries to support slicing like lists and strings do, to select a range of elements, e.g., `name_to_id['Alf':'Dave']`? Test your expectation. What about dictionaries that have integers as keys, do they support slicing to get a range of elements? Why might this be?
MW	Do you expect the keys in a dictionary to be case-sensitive? Test this.
***Not yet relevant: MW  If you need a mapping from a fixed range of consecutive integers to values, would a dictionary be a suitable datastructure, or would you use something else?

MW	Similar to assigning a value to a particular index in the list (e.g., `names[3] = 'Bert'`), you can assign a value to a particular key in the dictionary (e.g., `name_to_id['Suzy'] = '124987'`). What happens if the key to which you assign a value already exists in the dictionary? What happens if it does not yet exist in the dictionary? Relatedly, what happens if there are duplicate keys already at the moment you create a dictionary, e.g., `my_dict = {'a': 1, 'b': 2, 'a': 3}`?
MW  What do you think `del name_to_id['Esra']` does? Try it! In fact, does this syntax also work on lists? Construct a list (like `names` from previous sections) and try to delete the item at one of its integer indices. Do you expect it to work on a string as well, i.e., to delete a character from the index in a string? Why (not)?
MW	Oops, the `name_to_id` dictionary contains the wrong ID for Chris! It should be `'5987162'`. Also, Suzy has quit the course, so let's remove her entry from the dictionary altogether.
MW  Interestingly, dictionaries are also used under the hood for storing the ordinary variables you create -- remember the `globals()` and `locals()` dictionaries from the previous section? What does the following code show?\n```
x = 5
print(x)

globals()['y'] = 10
print(y)
```
MW  In the above example, PyCharm will likely warn you, with a red squiggle on the last line, that the variable `y` has not been defined. But Python itself doesn't care; the code runs fine! This means that PyCharm's warnings are based on a more shallow parsing of the code (called **linting**), not on actually interpreting it fully like Python does. Why might that be?


Subtitle    Mini-adventure: Language generation with feature structures

MW  Briefly review your random sentence generation code from Section 7. In the current section we will explore a different approach, relying heavily on dictionaries.
MW	Dictionaries are useful for representing so-called **feature structures**, i.e., bundles of features with values. This lets us represent a vocabulary as a list of dictionaries, as illustrated below. Extend this vocabulary by adding different words:\n```
vocabulary = [
    {'word': 'walk', 'category': 'verb', 'frame': 'intransitive'},
    {'word': 'see', 'category': 'verb', 'frame': 'transitive'},
    {'word': 'student', 'category': 'noun'},
    {'word': 'the', 'category': 'det'},
]
```
MW  As a warming up, use list comprehension to construct a new list from this vocabulary containing only all verb entries, and another one containing only nouns.
MW  As another warming up, use `import random` and then `random.choice(...)` to select a random determiner from the vocabulary, a random noun, and a random intransitive verb, and concatenate their word forms with spaces into a simple sentence.
MW  Now create a more general function that randomly generates a sentence based on the above vocabulary. It should output a single string composed of word forms (so not showing all the other features). Try to do so by defining and calling auxiliary functions corresponding roughly to natural language constituents, e.g., a `vp` function that generates a random verb phrase, a `dp` function that generates a random determiner phrase (like 'the student'), and so on. Your `vp` function should be sensitive to the `frame` feature in the vocabulary entries of verbs, and include an object `dp` where necessary. You can also make your `dp` function refer to an `np` function that generates noun phrases with an optional adjective (like 'smart student').
MW  For testing, implement a simple loop that prints out, say, 20 random sentences generated by your grammar.
MW  Add thematic role information as a feature to your verb entries (e.g., `'subject': 'agent'`), and relevant semantic information to your noun entries (e.g., `'animate': True`). If you let the `vp` function return not just a string but also the subject's required thematic role, you can feed this role as an argument to the `dp` function to generate a subject with appropriate semantic features (e.g., if an 'agent' is required, it should check the 'animate' feature of the noun).
MW  There is in principle no limit to the amount of (word-level) information you can store in feature structures! As a final exercise, let us add phonetic information to each vocabulary entry, e.g., for walk add a feature `'phon': '/wɔːk/'`. For our small example vocabulary you can manually copy phonetic transcriptions for instance from Wiktionary (https://en.wiktionary.org/); for a larger vocabulary you would of course write a Python script do to this extraction automatically. Next, add a boolean parameter `phon` to your sentence generator, with default value `False`, that lets you choose whether to return a sentence in orthographic or phonetic format.
MW  Write down some possible directions in which one could take this mini-adventure, whether as a research project, a practical application or a fun hobby.


Title    Dictionaries advanced

MW	Can you loop over a dictionary with `for` by using the same syntax as looping over a list? Try to loop over the dictionary `name_to_id` from above, printing each element. Which elements get printed, the keys, the values, or both?
MW	There are three other ways of looping over a dictionary: you can loop over elements in `name_to_id.keys()` (e.g., `for key in name_to_id.keys()`), over elements in `name_to_id.values()` and over elements in `name_to_id.items()`. Try the three versions, in each case simply printing the elements in the loop, and see what gets printed.
MW	If you loop with `for item in name_to_id.items():`, note that what gets printed (each `item`) are _pairs_ of a key and a value (try printing `type(item)`). A pair (or more generally _tuple_) can be _unpacked_ by assigning it to two variables separated by a comma, like this: `for key, value in name_to_id.items():`. (Recall that we saw tuple unpacking before, in the Pythonic way of switching two variables, `x, y = y, x`.) Use this to define a function `print_dict` that takes a dictionary, and loops over its items to print keys and their associated values separated by a colon: `key: value`.
MW	Define a function `update_dict` that takes two dictionaries, and adds all items of the second to the first (modifying the first dictionary in-place). To test this function, construct another dictionary `name_to_id2` with a bunch of fictional names and IDs different from those in the original `name_to_id`.
MW  In fact, the function you just defined should achieve the same as the built-in dictionary method `update`, i.e., `name_to_id.update(name_to_id2)`. Test this, after first resetting `name_to_id` to what it was before. (The existence of built-in `update` doesn't make the previous exercise pointless; it has given you experience with looping over dictionaries, and, having implemented an `update` function yourself, it will be easier to remember what the built-in `update` does.)
MW  What are differences (in functionality) between the `update` method and assigning a value to a key using direct assignment (`=`)? What happens if you confuse the two, e.g., `name_to_id.update('Bobby') = 5`, or `name_to_id.update(Bobby=5)`, or `name_to_id.update('Bobby': 5)`?
MW	Do the dictionary methods `keys`, `values` and `items` return an ordinary list (since we could loop over it), or a different type of object? Do these types of objects support indexing and slicing like a list? If not, it might occasionally be convenient to convert them to a list with `list(...)`. Try this, and see if the resulting list does support indexing and slicing (as one would expect).
MW  What sort of object do you get if you convert the whole dictionary to a list (without going through the `keys`, `values` or `items` methods), like `list(name_to_id)`? Can you reconcile this with the things we looped over when doing `for x in name_to_id:`?
MW	What determines the order in which the keys are iterated over? Form a hypothesis by defining several dictionaries (and also adding some new items to them later) and iterating over their keys, printing them (you can use your own `print_dict` from before).

Note	Until Python 3.6, the **order** of items in a dictionary could depend on the particular implementation of Python, and was _not_ to be relied upon in Python code. Since Python 3.7, however, dictionary order has been promoted from an implementational side-effect to a core feature of dictionaries: when iterating over a dictionary, the elements are now guaranteed to be given in the order in which they were added to the dictionary (whether in the initial dictionary definition (from left to right) or through subsequent assignment).

MW   Write code that relies on dictionary order (in Python 3.7 or higher) to get the value whose key was first added to the dictionary, and code to get the value whose key was last added to the dictionary.
W3R	 Write code that gets whatever value belongs to the maximum key in a dictionary. You can either do this with the help of built-in `max`, or without it, for extra looping practice.


Subtitle    A bit about tuples

***Insert some sorting exercise here too. Sorting tuples and itemgetter(1).

MW	Iterating over `name_to_id.items()` yields tuples. What are some other contexts in which you encountered tuples so far?
MW  The standard way to define your own tuple is as a series of comma-separated expressions in parentheses e.g., `my_tuple = (1, 3, 5)`. Experiment with tuples: What types of values can they contain? Can you access their elements by index? What about slicing a range of indices? Are tuples mutable? What happens if you omit the parentheses from your tuple declaration? Can you create an empty tuple? Can you convert a tuple to a list? To a string? Vice versa (like `tuple('abc')` perhaps?)? Does a tuple have a length? Can you concatenate two tuples into a new one using `+`? Can an element of a tuple be itself a tuple? Can tuples be compared with operators like `<` and `>`?
MW  Comma-separated values are commonly used also to let a function return multiple values at once (e.g., `return x, y`), and for _unpacking_ a tuple (as in `for key, value in name_to_id.items()`), and for the Pythonic way of swapping values (e.g., `x, y = y, x`). Do all of these uses also permit surrounding the comma-separated expression lists with parentheses?

Note    Comma-separated expressions in Python form _expression lists_, and an expression list containing at least one comma (and commonly, but _not_ necessarily, surrounded by parentheses) yields a **tuple** (except when part of defining e.g. a list like `[1, 2, 3]`). Note that it is _not_ the parentheses that signal to Python that you are defining a tuple, but rather the comma (_except_ when defining an empty tuple, which is done with `()`).

MW  Suppose we accidentally end our line with a comma, like `a = 1,`. Invent a possible context where this typo could lead to a subsequent error.
MW	Although when creating tuples the parentheses are sometimes optional, sloppiness can lead to potentially unexpected results. Explain the difference between `(1, 2, 3) + (4, 5)` and `1, 2, 3 + 4, 5`.
MW	Explain the truth value of `True, True, True == (True, True, True)`
MW  Tuples are ideal for storing a (small) number of fixed values with a fixed order, such as a name with a student ID and email address, or the coordinates of a point in 3D-space `(x, y, z)`. If you need to store more data fields (e.g., email address, average grade, place of birth...) then a dictionary usually becomes more convenient than a tuple, and if you need to store an in principle unbounded number of (typically more homogeneous) elements, a list is preferable. Can you identify reasons for these preferences? Reflect on the varying use-cases of these three data structures.
MW  Recall the relation between dictionaries and **hashability**. There is also a relation between hashability and mutability: objects that are intended to be mutated, like lists (and also dictionaries themselves), are typically not hashable (try this). This is because the hash code of a container object is computed based on the hash codes of the objects it contains, such that changing the objects it contains (as mutability allows) would cause the hash code of the container object to change, and the latter would cease to be a suitable, fixed 'anchor' for storing and retrieving objects in a dictionary. Test whether tuples are hashable (e.g., can they be used as keys in a dictionary?). Based on this, do you expect tuples to be mutable? Test this, too.
MW  Is the following statement true? 'The fact the items of a dictionary are tuples, shows that tuples are hashable.'
MW	Tuples are immutable, lists are mutable, but tuples can contain lists... Can a tuple that contains a list as one of its elements, be used as a dictionary key?
***Introduce generator expressions earlier
MW  Recall that **list comprehension** syntax can be used for concisely constructing a list (e.g., from an existing list, a range, or more generally a 'generator expression', see below), like `[i**2 for i in range(10)]`. To construct a tuple in this way, instead of a list, merely surrounding it with round parentheses instead of square brackets doesn't work: `(i**2 for i in range(10))`. Does this match what you learned about defining tuples in Python? Instead, you need to explicitly construct a tuple using `tuple(i**2 for i in range(10))` (note that the same also works with lists: `list(i**2 for i in range(10))`). Try this.


Subtitle    List comprehension for dictionaries

***Introduce generator expressions earlier
MW	List comprehension-type syntax, or more generally 'comprehension', also works with dictionaries. More correctly, `... for X in Y` is a so-called **generator expression**, and the items it 'generates' can be collected not only in a list (`[... for X in Y]`), but also in a dictionary (among other datastructures), as long as `...` has the right format, namely key-value pairs in case of a dictionary. Given this, what do you think the following does?\n```
new_dict = {key: value for key, value in name_to_id.items() if key[0].lower() in 'aeiou'}
```
MW	Use comprehension to take an existing dictionary with strings as keys (e.g., `name_to_id`), and filter it, constructing a new dictionary that contains only those items whose key has an even length.
MW  Explain in ordinary English what the following comprehensions do: \n - `{name: len(name) for name in name_to_id}` \n - `{i: i**2 for i in range(10)}` \n - `{name: name[::-1] for name in name_to_id.keys()}` \n - `{key: value for key, value in name_to_id.items() if int(value) % 2 == 0}`
MW	Use comprehension to take an existing dictionary and invert it, swapping the keys with the values.
MW  Suppose we have a predefined list of English numerals `numerals = ['zero', 'one', 'two', 'three', 'four', 'five']` (or more). Use comprehension and `range` to create a dictionary from English numerals to numbers (0, 1, 2, 3, ...), and another one for the reverse mapping.

MW  In section 11 you created the file `text_utils.py`, containing functions `ngrams` and `tokenize`. This means that in your current working file (make sure it is placed in the same directory) you can do `import text_utils`. Do this and apply the `text_utils.tokenize` and `text_utils.ngrams` functions to a short text. For instance, copy a text from Wikipedia, a blog, or an e-book, and simply paste it into your program in between triple quotation marks `'''` (to allow newlines within the copied string), the entire string assigned to a variable `text`. (Mixing code and data in a single file is bad practice of course, but fine for now. We learn about reading text from a separate file later.)
MW  (Without peeking in the Week 6 adventure code:) Write a function `count_tokens` that takes a list of strings and returns a dictionary that maps each string to how often it occurs in the list. You can use comprehension to initialize a counts dictionary (mapping each string to 0), and then loop through the tokens list while updating the counts.
MW  Does your function `count_tokens` also work if you feed it a list of n-grams instead of a list of single tokens? If not, find a way to fix this (in your current working file or by changing the `text_utils.ngrams` function itself). You should then be able to print individual token counts, bigram counts and trigram counts.
***Already introduce Counter here, as a subclass of dictionary.**
MW	Conversion to a dictionary can be done with `dict`. Which types of objects can be converted to a dictionary? Can you convert an ordinary list to a dictionary? A string? (In each case, try to form an expectation before testing it.) What about a list of pairs (2-tuples)? What about a list of lists, where each inner list has two elements? What if one of the inner lists has only one element, or three? What about a list of two-character strings?
MW	Given that looping over a dictionary loops over the keys, what do you expect conversion to a list to do? Does converting a list to a dictionary and back to a list bring you back to where you started (e.g., `list(dict(some_list_of_pairs))`)?

***Many more exercises:  https://www.w3resource.com/python-exercises/list/   https://www.w3resource.com/python-exercises/dictionary/


Subtitle    Mini-adventure: Translation

MW	Create a dictionary `en_to_nl` that maps some English words to Dutch words. (You can also use another language pair of choice for these exercises.)
MW  Write a function `invert_dict` that takes a dictionary and returns a new, inverse dictionary, mapping the original values back to the original keys. Use this to construct a dictionary `nl_to_en` from the original `en_to_nl` you defined in the previous exercsie. Can you now use the two dictionaries to translate back and forth, e.g., assuming your original dictionary contained the word _tree_, what is the outcome of `nl_to_en[en_to_nl[nl_to_en[en_to_nl['tree']]]]`.
MW	To `en_to_nl`, add the English word _feather_ mapping to Dutch _veer_, as well as the English word _spring_, which also happens to translate into Dutch _veer_. Feed it into your function `invert_dict`. What is the problem, technically and conceptually? Illustrate this in code by inverting your dictionary `en_to_nl` once, and then inverting the result again, comparing the outcome to the original. (You can use your function `print_dict` from above to print the dictionaries in a more readable way.)
MW  In general, a single word can have multiple adequate translations, for instance if the word is ambiguous or if the target language has multiple synonyms. To account for this, define a different type of dictionary, `en_to_nl_multi` that maps each English word to a _list_ of Dutch words, e.g., `{'bat': ['vleermuis', 'knuppel'], 'tree': ['boom'], ...}`. Your previous function `invert_dict` does not work on this type of mapping (explain what the problem is), so write a new function `invert_dict_multi` that does work. Note that just switching keys and values won't be adequate; the inverted dictionary `nl_to_en_multi` should again be a mapping from strings to lists, just like the original. Your new inversion function should handle the _bat_ (_vleermuis_/_knuppel_) example correctly, and also solve the _feather_/_spring_ (_veer_) problem from the previous exercise.
MW  Write a function that takes a text and a dictionary as parameters, and returns a word-by-word translation of the text. You can of course use `text_utils.tokenize` to get the individual words for translation. If multiple translations for a given word are possible, choose a random one (using `import random` and then `random.choice(...)`). Add enough words to your dictionary to enable the translation of some simple sentences. For instance, feeding your translation function the sentence _The feather was very light_ (together with the `en_to_nl` dictionary) should result in _De veer was heel licht_.
MW  What if your text contains a word that is not in the dictionary? Give your translation function a third parameter `mask_unknown` that is a boolean with a default value True. If it is set to True, unknown words should appear as `<UNKOWN>` in the resulting string. If it is set to False, unknown words should simply be left untranslated (e.g., resulting in a mostly-Dutch sentence with some untranslated English words). You can of course use `in` to check if a word is included in the dictionary or not, but doing so will often lead to two dictionary lookups where one should suffice (consider why). The `get` method of dictionary objects is better here; enter `help({}.get)` in the Python console to see how you can use it.
MW  Naturally, a shortcoming of word-by-word translation is that any word order differences between languages are not accounted for. Illustrate this with a sentence of choice. Without programming, can you think of a reason why (or a way in which) n-grams could be used to improve the accuracy of automatic translation?



Title	Jumping out and skipping through loops (`break`, `while`, `continue`, `range`)

MW  We have seen before that `return` can be used (inside a function) to escape a loop when some condition has been met, causing the rest of the elements looped over to be skipped. Escaping a loop early is an important programming pattern to acquire, as it often results in cleaner and more efficient code. As a warming up, review your own solutions to the exercises of section 8 that involved this pattern.
MW  What is wrong with the following function? Can you fix it? **Note:** In this and the following exercises, for the sake of practicing the main topics of this section, stick to the multi-line loop structure (e.g., don't use list comprehension, `sum`, or `any` and `all`, about which we will learn in a later section).\n```
def has_any_odd(numbers):   # Note: The docstring is a lie.
    """
    Returns True if the list of numbers has any odd number; False otherwise.
    """
    for number in numbers:
        if number % 2 == 1:
            return True
        else:
            return False
```
MW	Write a function `has_any_vowel` that takes a _string_ as argument, and returns `True` if it contains at least one vowel, and `False` if it contains no vowels. Does your function ever inspect more list elements than necessary to reach a conclusion? If so, try to streamline your function.
MW	Write a function `has_only_odd` that takes a list of integers as argument, and returns `True` if all numbers in the list are odd, and `False` otherwise.
MW	Write a function `has_three_odd` that takes a list of integers as argument, and returns `True` if, and only if, at _least_ three numbers in the list are odd.
MW	Write a function `has_at_most_n_vowels` that takes a list of strings and a number `n` as argument, and returns `True` if, and only if, there are no more than `n` vowels in the list of strings (also looking inside individual strings).

Note  Whereas `return` lets you escape from a function (hence also from any intervening loop), `break` is more specialized: it lets you escape only the immediately enclosing loop, nothing else. This means that `break` is in many cases more suitable than `return`; we will review some cases below, after some initial practice.

MW  Execute the following code and try to understand the output:\n```
names = ['Alf', 'Beth', 'Chris', 'Dave', 'Esra']

for name in names:
    print('Checking:', name)
    if name[0].lower() not in 'aeiou':
        print('Got one!')       # Beth is the first consonant person, and the only printed name
        break
```
MW	How many names do you expect this loop to print? Test your expectation.\n```
for name in names:
    print(name)
    break
```
MW	And this one?\n```
for name in names:
    break
    print(name)
```
MW	Try to predict the output of the following program, then test your expectation:\n```
for name in names:
    if len(name) > 4:
        break
    print(name)
```

Note    As mentioned, `break` can often be more suitable than `return` for escaping a loop. For one, `return` is only available inside a function (but most code should be organized in functions so that's not a real limitation). In addition, `return` is not suitable for escaping a loop if the function should still do some further processing _after_ escaping the loop (see next exercise), instead of return right away. Relatedly, if `return` occurs inside nested loops, it escapes _all_ enclosing loops at once, whereas `break` escapes only the directly enclosing loop. Some programmers take a more principled stance: `break` would be preferable in almost all cases because it results in cleaner code, as it wears its purpose on its sleeve: `break` was _designed_ for breaking out of loops.

MW  Write a function `print_until_vowel` that takes a list of strings, and prints all strings until one is encountered that begins with a vowel, in which case it should break out of the loop and end by printing `Done!` (the latter makes `break` more suitable than `return` in this case).
MW  To practice with 'default arguments' from an earlier section: give your function `print_until_vowel` a boolean parameter `inclusive`, with `True` as a default value. If this parameter is set to True, the string that begins with a vowel should also itself be printed; if it is set to False, only the strings that precede it should be printed.
MW  Write code with nested loops to illustrate one of the differences between `return` and `break` mentioned above: that `return` escapes all enclosing loops, whereas `break` escapes only the directly enclosing loop.
MW	What happens if you use `break` in some other place in your code, not inside a loop?
MW  What is wrong with the following code (analogous to the example with `return` above)? Can you fix it? (Maintaining the printout of 'Zero odd numbers here!' in the negative case can be a bit tricky.)\n```
def print_whether_has_any_odd(numbers): # the docstring is a lie
    """
    Prints whether or not the list contains an odd number, and 'Done!' afterwards.
    """
    for number in numbers:
        if number % 2 == 1:
            print('It has an odd number!')
            break
        else:
            print('Zero odd numbers here!')
            break
    print('   ...really!')    # this final command is mainly why we use break to escape the loop, not return
```
MW  Fixing the preceding code is easier if you know that `for` clauses can actually be combined with an `else` clause, just like `if` can. Consider the following fix, and notice the indentation ensuring that the `else` belongs with the `for`, not with the `if`. Does it work correctly?\n```
def print_whether_has_any_odd_2(numbers):
    for number in numbers:
        if number % 2 == 1:
            print('It has an odd number!')
            break
    else:
        print('Zero odd numbers here!')
    print('   ...really!')
```

Note    Similar to if-clauses, for-loops can have an `else`-clause too. The else-clause of a for-loop is executed only if the for-loop finishes _without_ any `break`. Typically (but not always) `break` represents that some target element, that meets some criterion, has been found (e.g., the first odd number, the third name that begins with a vowel...). Therefore, you can often read the `else`-clause of a for-loop as "if no such element was found...". (If you pronounce it simply as 'else', it can be confusing.)

MW	Can a single loop contain multiple `break` statements, e.g., in different if-clauses? Can you think of an (imaginary) use-case where one might need this?
MW  _(You can do this and the next two exercises all at once, or one at a time.)_ A rich client needs four functions, that each take a nested _list of lists_ of numbers as parameter and return a boolean. One checks if _some_ (any) inner list contains an odd number (return True if so, False otherwise). The second checks if some inner list contains _only_ odd numbers. The third checks if _each_ inner list contains an (any) odd number. The fourth checks if _each_ inner list contains _only_ odd numbers. Implement a first version of these functions, where each function is self-contained and does _not_ rely on auxiliary functions (e.g., `has_any_odd` from before). Each function will, therefore, contain nested loops.
MW  Our client cares a lot of about efficiency (but insists on using Python). Do all of your loops escape early where possible?
MW  Our client also cares a lot about readability, and hates repetition. Improve the four functions such that each contains only a single (non-nested) loop, within which some auxiliary function is called that does the rest (e.g., `has_any_odd` from before, and you may need to define another).

MW  Besides `break` (and to some extent `return`), another keyword that helps you control your loops is `continue`. It lets you skip an element. Can you predict what the following code prints? Test your prediction and verify your understanding.\n```
for i in range(10):
    if i % 2 == 0 or i % 5 == 0:
        continue
    print(i)
```
MW  What `continue` achieves can also be done with an if-clause alone, without `continue`. Show this by re-implementing the above `for i in range(10)` example _without_ using `continue`.
MW  The foregoing notwithstanding, sometimes `continue` is considered preferable to a plain if-clause. A typical use case is to filter out cases that don't need to be processed, right at the start of the body of a for-loop. This is particularly desirable if the body of your loop is substantial. Compare program 1 and 2 in the code below (verify that the result is the same). In Program 1 the body is more deeply nested (under the if-clause), which means more stuff to keep in working memory as you try to understand the code. In Program 2, the body is less deeply nested, and `continue` directly, transparently signals that certain cases can simply be ignored, which is easier on our working memory.\n```
# Program 1, not using continue:
for i in range(1000):
    if i % 3 == 0:
        print(i)
        ... # imagine a substantial program here

# Program 2, using continue:
for i in range(1000):
    if i % 3 != 0:
        continue        # exception-status immediately clear

    print(i)
    ... # main program is now not as deeply nested, which is also nice
```


Subtitle    Looping with `while`

MW	The `while` keyword lets you loop in a way that is different from for-loops. Run the following and make sure you understand what's happening. As before, try to break it in various ways.\n```
counter = 0
while counter < 10:
    print(counter)
    counter += 1
```
MW  Write a program that does the same, but using a `for`-loop instead of the `while`-loop above (this is not just a matter of replacing the keyword; more things have to change).

Note	For the above use-case, where you know in advance how often to repeat something, for-loops are normally the way to go. But **while-loops** can be convenient if you don't quite know how long to loop, e.g., until some unpredictable condition is met, such as a particular user input. We will see some examples of this.

MW	If a program keeps on running, do you know how to intervene to stop it? In the Python Console this is often the keyboard shortcut `ctrl`+`c` or `cmd`+`c`; when executing a script it may be `ctrl`+`F2`, but the PyCharm IDE also has a visual stop button for this (red square).
MW	In the above while-loop, replace the condition (`counter < 10`) simply by `True`. What do you expect will happen? Do you see the importance of the previous exercise?
P4E	Write a function that repeatedly gets numbers from the user (using the `input` function), until the user enters _done_. Once _done_ is entered, print out the total, count, and average of the numbers. You can assume the user will only enter either `done` or a valid number.
TP3	Write a number guessing game. Start your program with `import random`. Write a function that contains `number = random.randint(100)` (what does it do?), followed by a loop asking the user to guess that number. Upon each guess (you can assume the user enters only valid numbers), the program prints whether it is too high or too low, or, if the guess is exactly right, exit the loop and print _Congratulations! You won in [n] guesses!_ where _n_ is the number of guesses.
MW  Use `continue` to make your number guessing game, from the exercise above, more user-friendly: if the user enters anything other than a number, skip ahead (with the effect of asking for new input right away). You can use the string method `is_numeric`, which returns True if the string contains only numeric digits.

***Much work for little gain: MW  Using your sentence generation code from Section 12 (or the simpler variant from Section 7), write a while-loop that generates a random sentence every time the user presses `enter`, and stops when the user enters `quit`.
***Not very relevant: MW	Write an infinite loop that prints the next prime number each time the user hits enter (you can use `input()` for this).
***MW	Modify the guessing game: if the player guesses correctly, after congratulating them, ask the player if they want to play again, and if so, sample a new random number and start over. After each game, give the player some additional feedback: did they use more or fewer turns than the average of previous rounds (within the same session)?
***MW	Write a program with a while-loop that repeatedly takes a string from the user, and simply repeats it back to you _unless_ it contains a profanity, in that case it remains silent. You can get creative (and naughty), or find lists of profanities on the web. (In a later section we will learn how to read such words from a separate file, so you don't need to copy them into your program.) If you enter more than 5 profanities, the program should say _I've had enough of this_ and change the value of a boolean such that the while-loop stops.
***Not super needed: MW	Write a program that repeatedly asks for user input; it ignores all user input except the string _knock_. Only if the user writes _knock_ three times in a row (as three separate inputs), the program should print _Go away!_ Note: if you enter _knock_ twice, then something else, then _knock_ a third time, nothing should happen; the three knocks should be consecutive.

***redundant.** Note    When writing a loop, you should always consider: Do I know in advance over which elements I need to loop, or how often to repeat something? (If so, use `for`; if not, perhaps `while`.) Do I need to look at all elements in all cases? Or can I take an early exit (`break`, sometimes `return`)? Under what conditions? Are there exceptions I can skip right away (`continue`)?

***Not very relevant: MW  As a final practice with `continue`, define a function that takes a list of strings and loops over it. Inside the loop it should ignore (with `continue`) strings that have an even number of consonants, and for those strings which it does not ignore, invert them and append them to a new list, which is returned in the end.


Subtitle    Looping over `range`

***Not super relevant here: MW  As a warming up, consider the following, famous programming job interview question, known as `FizzBuzz'. Write a function that iterates the integers from 1 to 50, printing the numbers. However, for multiples of three print `Fizz` instead of the number, and for multiples of five print `Buzz` instead of the number. For numbers which are multiples of both three and five print `FizzBuzz`. Try to minimize repetition in your code.
MW	We have already used `range` to loop over a range of integers, e.g., `for i in range(10):`, but `range` is quite a bit more flexible. Execute `help(range)` in the Python console for more information (and remember to press `q` to quit). As you can see, you can construct a range with up to three arguments. What do the other arguments do? E.g., what happens if you loop over `range(3, 50, 5)`? And what about `range(100, 5, -3)`? Is there a relation between the three arguments of `range`, and the three integers you can specify when slicing a string or list?
MW	Write a function that counts down from 10 to 1, and then prints _Lift off!_. (Consider printing all numbers on the same line, to more easily keep an overview in your printed output. Also consider adding `flush=True` to a print statement now and then, so you don't have to scroll all the way up to see an error message.)
MW	Generalize the preceding function by providing it a start and a step parameter, where the default start is 10 and the default step is -1. Use it to count down from 20 in steps of 2.
MW	Define a function that uses nested loops to print all pairs of numbers, each between 0 and 10 (inclusive), where the first is odd and the second is even. Did you use if-clauses inside the loops, or did you solve it with particular `range` objects instead?
MW	Define a function that uses nested loops to print all pairs of numbers, each between 0 and 10 (inclusive), where the second is higher than the first -- but, for the sake of practice, _without_ using an `if`-statement (hint: the inner loop can use a range of which the starting point is determined by the outer loop). (Can you reason about how many such pairs there will be?)

Note	When you need to loop over a range of numbers in a particular way, choosing a smart `range` can sometimes result in more readable code than using if-statements inside the loop, especially in list comprehensions.

MW	Write a function that takes a list, and returns a new list containing all elements that occurred at even indices (0, 2, 4, ...) in the original list. Write a version that uses a multi-line loop, and a version with only list comprehension.
MW  Write a function that takes a list and returns a new list containing all non-overlapping _pairs_ of elements in the original list. So for input `[1, 2, 3, 4, 5, 6]` it would return `[(1, 2), (3, 4), (5, 6)]`. Try two variants: a multi-line loop and list comprehension. Which do you find more readable in this case?
MW  Generalize the foregoing function with an integer parameter `n`, returning the list of non-overlapping n-tuples (pairs, triples, quadruples, etc.). This is likely too complex for a single-line list comprehension. Moreover, you will likely need two `range` objects, one for looping through the list, one for constructing each tuple (from index `i` to index `i + n`). Remember from the previous section that constructing a tuple using list comprehension requires an explicit `tuple(...)` expression.
MW	Can you create a `range` with non-integer steps, e.g., 0.1? What about using a float as a starting point or end point, is that allowed? Can you think of a more indirect way to nevertheless achieve such things (e.g., float steps or start/end points) whilst still using `range`?
MW	Define a function that takes an integer parameter `n` and uses a _single_ loop to repeatedly, `n` times, print the numbers 0, 1, 2, ..., 23 (as if `n` days pass on a 24-hour clock).
MW	Remember that objects can sometimes be converted from one type to another. A `range` object can be converted to a `list`, e.g., `list(range(100))`. Try this. Can you also convert a list back to a range? What happens if you try, and why might this be?
MW	In the Python console compare `x = range(9999)` to `x = list(range(9999))` (without printing the result). Keep increasing nines and try again, e.g., `99999`, `999999`, `9999999`, and beyond (take it easy, don't crash your computer). At some point you will notice that the version `x = list(range(999...9)` gets much slower, while the version `x = range(999...9)` remains fast. Why would this be?
MW  If you do `import sys`, you can access various operating-system-related functions in Python. One of these is the function `sys.getsizeof`. First call `help` on this function to read what it does. Then use the function to compare `range(9)` to `range(9999)`, and `list(range(9))` to `list(range(9999))`. Do your findings align with your answer to the previous exercise?
MW	We have a micro-computer with a tiny display of 8 by 8 pixels, each of which can only be either on or off. We received what appears to be a secret message: `0000000000110110011111110011111000011100000010000000000000000000`. Write a function that takes such strings and prints them to a (simulated) 8 by 8 display, each pixel represented by a one-character space, rendering a `0` as an empty space ` `, and a `1` as a hashtag `#` (use a dictionary to implement this mapping, rather than if-statements). If you like, compose your own reply.


Subtitle    Wrapping up

MW	To conclude this section, in the Python console enter `import keyword` and then print `keyword.kwlist` (we will learn the details of `import` later). For which of these keywords do you already know some purpose? Try to summarize your understanding, especially of the keywords central to this section (`break`, `continue`, `return`, `for`, `while`): what is the purpose of each of these keywords?

Note    **Keywords** are core language constructs handled by the syntactic parser before Python code is interpreted. Keywords are _reserved_ and cannot be used as ordinary variables, e.g., reassigned new values. **Built-ins** are commonly used, preloaded functions (e.g., `print`, `round`) and classes (e.g., `list`, but also various error classes such as `TypeError` -- if you encounter a TypeError, it is an instance of this class).

MW  Test that keywords are indeed special, reserved expressions, by showing that trying to assign something to a keyword leads to an error.
MW  Unlike keywords, built-ins are assigned to ordinary variables, hence these can be reassigned new values. For instance, try `print = 'bla'` and subsequently try to print something, like `print('apple')`. Overriding builtins like this is not a good idea. (If you did this in the Python console, consider restarting it now to prevent confusing your future self.)
MW  Built-in functions are in fact shortcuts for objects you can also find in `__builtins__`. Try printing `__builtins__`. Depending on implementation it is either of type `module` (the type of thing that results from `import`, about which we will learn later) or a dictionary. In fact, in PyCharm, `__builtins__` in the Python Console is equivalent to `__builtins__.__dict__` in a script. Do `print(dir(__builtins__))` in a script (`dir` lists the contents of a module), or `print(list(__builtins__))` in the Python console (to list the keys of the dictionary). For which of the built-ins do you already know some purpose?


Title   Basic text processing (`split`/`join`, `strip`, `read`/`write`, `set`)

MW	Before learning how to read and write text files, it will be convenient to first learn a couple more basic string methods, that can be helpful for cleaning the data read from a file. As a warming up, look at `dir(str)`, or equivalently `dir('some_random_string')`, for a list of methods available on the string class itself. Explore at least the string methods `strip`, `swapcase`, `isalnum` and `center`; use `help` if needed (e.g., `help(str.strip)`) and illustrate how they work with your own examples.
MW	What is the difference between the string methods `split` and `rsplit`? Illustrate with your own example.
MW	Assume that we have assigned `test_string = 'abcblablablaabc'`. For each of the following invocations of `strip`, form an expectation about what it does (based on the `help` you obtained) and then test it (e.g., by printing the result), refining your understanding of `strip`:\n - `test_string.strip('abc')` \n - `test_string.strip('cba')` \n - `test_string.strip('a').strip('b').strip('c')` \n - `test_string.strip('c').strip('b').strip('a')` \n - `test_string.strip('bla')`
MW	Call `help` on the `str.join` method, look at the example it provides, and try to apply it to join your own list of strings with a dash `-` in between. Pay attention: on which object is the `join` method called, on the joiner or on the joinees?
P4L Define a string `s` for which the following is _not_ true: `' '.join(s.split())`.
MW  What happens if you try to join a list that contains objects other than strings, e.g., integers?
MW	There may be something counterintuitive about `join` and `split`: why is `split` called as a method of the string-to-be-split (with the string that joined them, `'-'`, as an argument), while `join` is _not_ called on the strings to be joined, but rather, on the string used for joining them? For instance, in the above code, `'-'` is the argument of `split`, but not of `join` (for which it is the object providing the method). The following variant would be more 'symmetrical' in this regard, as the connecting character `'-'` would be the argument in both cases. However, test this to see what type of error you get (and then fix it):\n```
names = ['john', 'sue', 'bob']
names_joined = names.join('-')	# Doesn't work!
names_unjoined_again = names_joined.split('-')
print(names == names_unjoined_again)
```
MW  Two things can help you remember the aforementioned apparent asymmetry. First, try to think of a natural way in which to read `join` and `spit` commands, respectively, that will help you memorize the aforementioned apparent asymmetry. Second, try to understand _why_ Python was designed this way, i.e., why `join` is _not_ called as a method _of the list to be joined_, but as a method of the string to join by.
MW	Oh no! I copied a list of student names from a low-quality PDF and now all names are surrounded by weird symbols! See below -- imagine the list is much longer (so manual cleaning is not an option) but the type of 'noise' remains the same. Define a function that uses `split` and `strip` to return a list of separated, cleaned-up names:\n```
names = '''#*John#*
#*Mary# *,
*#*Suzy#*,
#*Bob#\t*;
#* Chris#\t*'''
```
MW	Oops, copying from a different PDF resulted in even more mess, where all names are in uppercase and some characters were misread as similarly-shaped numbers. Can you clean it up similarly? Hint: there is a string method called `replace`.\n```
names = '''#*T0DD#*
#*0NA# *,
*#*SUE#*,
#*ANN-M4RY#\t*;
#* R0S5#\t*'''
```
MW  How does the string method `replace` work, exactly? What if the thing-to-be-replaced isn't there? What if it occurs multiple times? How can you use `replace` in order to _delete_ all occurrences of a certain substring? What do you expect the result of `'abc'.replace('', ' ')` to be (form an expectation first, then test it)?
***Not relevant here: MW	How does the string method `find` work? Call `help` on it if needed, and try it on some examples. What happens if the thing-to-be-found isn't there? (The latter behavior of `find` is known to be error-prone; can you think of why that is?) How does `find` differ from the method `index` that we saw before? Is `find`, just like `index`, available for strings and lists alike?
MW  Define a simple word-tokenizer that uses `split` on spaces and `strip` to get rid of punctuation, and compare it to your earlier attempt at word-tokenization (e.g., the one you put in `text_utils.py` as part of Section 11), noting some (possibly shared) shortcomings.

Subtitle    Reading and writing files

MW  Without searching the web, try to gather and formulate your intuitions: What is file? What is the difference between, and relation between, long-term storage (e.g., your harddisk, or the cloud) and working memory (RAM)? What is a folder (or directory)? What is a path (such as, depending on your operating system, `C:\Documents\semantics_report.pdf` or `~\Downloads\Alice_in_wonderland.txt`)? What might be the difference between an _absolute_ and a _relative_ path?

Note    WARNING: Before executing any code that involves opening a file, _always_ assume the worst: that the referenced file, if it exists, will be destroyed/overwritten. Make sure you do not loose valuable data in case this happens. Some things we will learn -- using a context manager, opening a file as 'read-only' where possible, using relative paths -- and in general clean code help decrease the chance of unintended changes to your files.

MW  Create a Python script with the following code. Execute it, then find the created file `test123.txt` on your computer and open it (it will be in the same folder as your Python script). \n```
with open('test123.txt', 'w') as file:
    file.write('Hello!')
```
MW  Experiment with the above code. What if, inside the `with`-block, you add a second write statement? What will be in the file if you repeat the entire `with`-block twice? Does a `with`-block create a local scope? Does this align with what happens if you try to write a bit more to the file _after_ (i.e., outside, non-indented) the `with`-block?
MW  What if you omit the second argument of `open`, the string `'w'`? What if you replace it by an `'a'` and run the code several times? In each case inspect the resulting file. The second argument of the `open`-call specifies the **mode**. The most common modes are read-only (`r`, which is the default), write-only (`w`), read-and-write (`r+`) and append (`a`). Call `help(open)` and find the table explaining the different modes. Based on the previous exercise, what is meant by 'trancating' in the explanation given for `w`?
MW  Assuming the file `test123.txt` now exists, execute the following code to read it. Does `file.read()` read one line at a time, or the full file contents (create a multi-line file if you want to test this)?\n```
with open('test123.txt', 'r') as file:
    text = file.read()
print(text)
```
MW  What happens if you try to read the same file twice in a row, _within_ a single `with`-block (and print the results of both reads)? What if you read the same file twice but in _separate_ `with`-blocks? First hypothesize about what may cause this difference, and only subsequently try to reconcile it with the following: When you open a file, a persistent pointer is created that to the 'current position' in the file, i.e., the index of the byte of the file that is to be read next. In read-only mode `r`, this pointer starts at 0 (start of the file) and is incremented while the file is being read. What will be the value of this pointer after reading an entire file?
MW  What do you think the starting value of the pointer of a file will be when you use append mode `a`? And what if you use write mode `w`? You can verify your predictions with code like the following (also try mode `w`), where the `tell` method reveals the value of the pointer.\n```
with open('test123.txt', 'a') as file:
    print('Pointer when appending:', file.tell())
```

Note  If you want to read from or write to a file in Python, you first need to **open** the file. The standard idiom uses the built-in function `open`, which takes a path and a _mode_ (read-only `r`, write-only `w`, read-and-write `r+`, append `a`), embedded in between the keywords `with ... as` for constructing a _context manager_. The latter ensures that the file is properly closed when you're done (as unintentionally leaving files open can have some downsides depending on Python version and operating-system). To prevent mistakes with reading and writing, keep in mind that files maintain a pointer to a 'current position' in the file.

MW  The above code created the file `test123.txt` in the same directory that contains the Python script, because it is a _relative_ path, i.e., it specifies the location _relative to_ the current working directory. An _absolute_ path specifies the location of a file all the way from the root of your file-system or home directory (e.g., `C:\` in Windows, `~` on Mac, Linux). Re-run the above code with different paths (though keeping the above warning in mind!), including an _absolute_ path to a place on your disk (e.g., depending on operating system, `C:\Documents\test123.txt` or `~/Documents/test123.txt`), and a _relative_ path to a sub-folder of the current working directory, e.g., `output/test123.txt` (first create such a folder if none exist yet).
MW  In PyCharm, you can right-click (or ctrl-click) on a file in the Project tab on the left, choose 'Copy path/reference' and select 'Absolute path' or 'Path from repository root'. Try this (copy, and then paste the copied path somewhere else, e.g., into a string in your python script). If your Python script is in the repository root (i.e., not in a sub-folder), then the latter corresponds to the _relative_ path from your Python script.
MW  How does writing to and reading from a file in the above manner relate to other input/output methods we have so far, both in purpose and in function? Consider `input`, `print` and `import`. For instance, with regard to function, do `write` and `print` behave differently with regard to newlines? Does `write`, like `print`, allow non-string arguments? Does it allow multiple arguments?
MW  Do you expect the following two code snippets, when executed separately, to have the same end result? What could be reasons for preferring one over the other? (And can you predict the file's contents if the second snippet, too, were to use write mode `w` instead of `a`?)\n```
with open('test123.txt', 'w') as file:
    for i in range(10):
        file.write(f'{i}\n')

for i in range(10):
    with open('test123.txt', 'a') as file:
        file.write(f'{i}\n')
```
MW  Instead of calling `read` on a file, you can also iterate over a file with a loop. Test the following on a multi-line file, and explain why the resulting printed lines all have empty lines in between.\n```
with open('test123.txt', 'r') as file:
    for line in file:
        print(file)
```
MW  What happens if you duplicate the above loop, such that (within the `with`-statement) it attempts to loop over the file twice? What happens if you duplicate the entire `with`-statement (each containing the loop once)? Does this align with what you learned earlier about calling `read` multiple times?
*** Maybe change the following to involve writing a file?
MW  To practice, write a function that opens a file and iterates over it, and in the end prints the average line length in number of characters and number of words (using a simple tokenization function from earlier).

Note    Unlike 'opening' a file in the way you are used to (e.g., opening a document in MS Word), opening a file in Python with `open` does not yet load the contents of the file into working memory. We have seen that calling `.read()` on an open file does the latter. Sometimes, if a file is particularly large (why then?), it is preferable to read it one line at a time, which you can do by iterating over the file itself.

MW  Can you also use list comprehension to iterate over a file? Try this, to collect (for instance) the first character of each line in a file, to construct a list containing the separate lines of the file, and to construct a list containing the separate lines of the file where each line has been _stripped_ of its final newline character `\n`.
MW  In this and the next few exercises you will be writing a function `read_from_gutenberg`, that will serve as good practice and be useful for subsequent sections. It should take a path to a `.txt` file you downloaded from the Gutenberg project (https://www.gutenberg.org/) and simply return the file's text content as a single string. In the next exercises you will make this function more sophisticated.
MW  Text files from the Gutenberg project contain some meta-information (title, author, licence, etc.) that must be distinguished from the actual, original text: look in such a file for lines beginning with `*** START` and `*** END`. Enhance your `read_from_gutenberg` function so that only the original text (between the `*** START` and `*** END` lines) is returned.
MW  Modify your `read_from_gutenberg` function so that instead of ignoring the meta-information, it parses the file-initial portion (with, e.g., title and author information) and returns it as a dictionary. More precisely, any line above `*** START` that contains a colon, should be added to the dictionary as a key-value pair. Your function will thus return both the extracted text and this dictionary.
MW  One further enhancement: text files from the Gutenberg project are 'hard word-wrapped', meaning a newline character was inserted whenever a line exceeded (e.g.) 75 characters. Since these single newlines (`\n`) were not meaningful parts of the original text, we want to get rid of them (e.g., replace them by a space). However, we do not want to loose the information carried by _double_ newlines (`\n\n`), which _do_ represent a meaningful aspect of the original text, namely paragraph separations.
MW  Move your `read_from_gutenberg` function to the file `text_utils.py`, as we will use it in the next section too. Use this function to load a text file from the Gutenberg project, and tokenize it (whether by using split, or a method already in `text_utils.py` from earlier) to obtain the list `tokens`.

***MW  `os`, exists, define a `can_write` function

***If you move your entire project (including the referenced file) somewhere else, then the absolute paths will no longer work, while the relative paths keep functioning. On the other hand, if you move only your Python script (containing the path reference) somewhere else on your file system (even within the project folder), then the absolute paths will keep functioning, while the relative paths no longer work (though for changes within the project, executed in PyCharm, the latter may offer some help updating them automatically). And of course if you move the target file someplace else, independently of your Python script, then both absolute and relative paths will break.


Subtitle  Unique elements (`set`)
MW  When processing texts it is often useful to get the _unique_ elements (e.g., words, bigrams, part-of-speech combinations, consonant clusters) from our data and _sort_ them (e.g., alphabetically, by occurrence count, by similarity to some search query). Python's _set_ data structure contains every element only once, hence creating a set from a list (or other collection) amounts to filtering out duplicates, leaving each unique element once. Construct a set from the `tokens` list from above by doing `set(tokens)`.
MW  Print an overview of the methods provided by the resulting set object (with `dir`).
MW  In maths/set theory, sets are written with curly braces like `{1, 2, 3}`. Does that work in Python, too? What about creating an empty set like this `{}`? (Make a prediction, but also try it and, just to make sure, check the type of the resulting object.) Can you find some (other) way to create an empty set?
MW  Can you create a set containing strings? A set containing tuples? A set containing lists? Why (not)?

Note    The **set** data structure contains each element only once. Moreover, sets are significantly faster than lists when it comes to determining if an object is present in the set. (Though lists are much faster if you know the index of the object you are looking for.) The price to pay for this lookup speed is that sets can only contain objects that are **hashable**, just like a dictionary's keys.

MW  Do you remember some objects that are, and some objects that aren't hashable?
MW  Do sets have a 'length' (`len`)? Can you check with `in` whether a set contains a certain element? Can you iterate over a set? Can you construct one set from another using comprehension syntax? Do you expect that you can use slicing on a set, as you would with a list? Why (not)? Test your expectation.
MW  After creating a set, one can add elements to it with the method `add`, e.g., `my_set.add(5)`. What happens if you try to add an element that is already in the set? Do sets also have an `append` method like lists? Why might this be?
***MW   Union, intersection and complement?
MW  Can you predict what happens if you construct a set not from the tokens, but from the original, un-tokenized text directly? Verify your prediction.
***Write the vocabulary to a file
***Write code to obtain combined vocabularies from several files? Maybe use glob or os.dir for this?




Title    Counting and sorting


Subtitle    Sorting

MW  Use your function `read_from_gutenberg` from `text_utils.py` (Section 15) to load a text file from the Gutenberg project, and tokenize it to obtain the list `tokens`. Additionally, feed the tokens into a `set` to obtain a vocabulary.
MW  The _order_ of the elements in a set (e.g., the vocabulary) must _not_ be relied upon (unlike lists and, in recent Python versions, dictionaries), as it depends on hash-codes which (in most Python implementations, for anything but the most basic types of objects) will vary between runs of the same program. Verify this by writing `print({'aaa', 'bbb', 'ccc', 'ddd', 'eee'})` in your script and running the script several times, noting the different orders in which the set gets printed.

***MW  Sorting exercises.

Note  Among Python's built-ins there are two main functions for **sorting** (with various other libraries providing additional, special-purpose sorting functions, e.g., the Pandas library for sorting Dataframes): The function `sorted` takes an 'iterable' (anything over which you can iterate) and turns it into a sorted list; the list method `sort` is available only for lists and modifies a list in-place. Both functions take an optional argument `key`, that lets you specify a function that specifies what to compare the to-be-sorted elements on.

***MW  More sorting exercises
MW ***Exercise about itemgetter   .\n```
from operators import itemgetter

words.sort(key=itemgetter(1))
```
MW  Returning to the text from Gutenberg, sort its vocabulary in various ways (separately): alphabetically, by word length, and (for practice) by the second character. Can you do this by calling `sort()` on the set itself, or should you use `sorted`? Why?
MW  Viewing the vocabulary, especially when sorted alphabetically, can reveal some shortcomings of the tokenization and further pre-processing steps currently used. Can you find some vocabulary entries that you think ought to be split up? And pairs of vocabulary entries that you think ought to be treated as one and the same?
MW  Try to make at least some improvements to the derived vocabulary. Some of these are best handled by improving the tokenizer, others by applying prior standardization steps to the raw text or a subsequent filter to the derived vocabulary.
***Already introduce Spacy/NLTK/TextBlob's lemmatization here. Maybe just let the student choose a library and figure it out?
MW  How many unique tokens (or token types) does it have? Compute the _lexical diversity_ of the text, as the total number of tokens divided by the number of unique tokens.
MW  Assuming our purpose is to compare the lexical diversity of books (as on Gutenberg) and some other textual medium (e.g. tweets). Do you think verbal inflection ought to be standardized when computing it, e.g., treating _walk_, _walked_ and _walks_ as the same entry? If not, can you think of some other purpose (research or applied) for which verbal inflection should probably be standardized? Can you think (in outline) of an algorithm to achieve this? (In Section 17 we will encounter two common approaches: _stemming_ and _lemmatization_.)

Subtitle    Counting

MW  Although sorting by itself is an important tool, the combination of counting-and-then-sorting-by-count is so common that a specialized tool exists: the **Counter** class from the `collections` module. Execute the following code and show with code examples that the `Counter` object behaves in many ways like a dictionary.
***also update, most_common(5)   (with no argument, returns full sorted list)
***MW  sort on the first string character only, then by count.
***MW  How many times does the word ... occur?
***MW  On a large dataset, compare the efficiency of Counter to that of your own counter function. For a noticable difference, apply it to a sufficiently large (tokenized) text and (if the result is still practically instantaneous) call the function 100 times instead of only once. (Optional: consider using `timeit`.)
***P4E More alice exercises end of chapter 4; io3.py, io6.py, etc.
MW  What does `Counter.elements()` represent?
MW  Write a function that takes a dictionary (or Counter) of word counts and a path for the desired output file, and writes all words with their counts to the file. Each line should have a word and its count, separated by a comma. The typical extension for this type of file is `.csv` (do you know what it stands for?).
MW  Extend your function with an additional boolean parameter `sort_by_count`, with default value False. When True, the words should be written to the file in order of decreasing count (i.e., most frequent first); when False (default), the words should be written instead in alphabetical order.
MW  Now write the inverse type of function, that takes a path to such a `.csv` file with word counts, and reads it line by line to construct a Python dictionary from it. (In a later section we will be working more with .csv-type data, using the library `pandas`.)
MW  Generalize the function for writing counts to a file by adding an additional parameter `ngram_range`, that has the tuple `(1, 1)` as a default value meaning it counts only 1-grams (individual words). Passing, e.g., the pair `(1, 3)` as an argument should instead result in a file containing all 1-gram, 2-gram and 3-gram frequencies; and `(3, 3)` should result in a file contain only tri-gram frequencies. (This is unlike Python's built-in `range`, which, recall, _excludes_ the upper bound, but it aligns with the way n-grams are handled in the popular machine learning library `sklearn` (SciKit-Learn).) The resulting `.csv` should still have only two columns; represent n-grams simply by space-separated words (e.g., the line `the lazy cat,123` should represent that the tri-gram _the lazy cat_ occurs 123 times. If necessary, generalize your inverse function from above, i.e., that reads the counts back from a `.csv` file, to handle n-gram counts correctly.
MW  A conceptual exercise (though feel free to experiment with code): Do you think token counts obtained from a document could be used to obtain a list of words that represent the main _topic(s)_ of that document? If not directly, can you think of a way to transform (e.g., scale, divide, normalize) the token counts in such a way that the tokens with the highest values will be (more) representative of the topic(s) of a document? (Spoiler: this exercise may lead you to invent the _TF-IDF_ algorithm (Term Frequency, Inverse Document Frequency), which is one of the most popular techniques in topic modeling and information retrieval; we will learn about this in a later section.)
MW  Another conceptual exercise: Recall that, for our weeks 8-9 adventure on similarity and distributional semantics, we computed a matrix of **co-occurrence counts** given a certain window size (do you remember the relation between co-occurrence counts and similarity, conceptually and technically?). Does such a matrix represent essentially the same information as a table of _n_-gram counts for some suitable _n_ (e.g., _n_ equal to the window size perhaps, or window size + 1 depending on implementation?). That is, can we define some transformation to obtain one representation from the other? Or do they represent genuinely different information, not reducible to one another?
MW  **Collocations** are words that occur together more often than one would expect based on their individual frequencies. Examples are 'regular exercise', 'fast food', 'richly decorated'. Define a function that takes unigram counts (individual words) and bi-gram counts, computes a degree of 'collocation-hood' for each bigram, and returns the bigrams ranked from most to least 'collocational'. Inspect the top results for a text of your choice. (Hint: First turn the counts into (estimated) probabilities by dividing them by the total number of tokens (or bi-grams), then compare (in pseudo-maths) `prob('word1') * prob('word2')` to `prob('word1 word2')`).
MW  Generalize the previous function to find potential three-word collocations, and inspect the outcome.
MW  Generalize the foregoing to be able to find not only word-level collocations, but also character-level collocations (e.g., perhaps 'sh' is more common than one would expect based on 's' and 'h' alone). Can you think of other potentially collocational character combinations? Test your expectation on a text of your choice.

Subtitle    Mini-adventure: _n_-gram-based language models
MW  Think of a way in which we can automatically generate text by, repeatedly, randomly sampling the next word given previous words, on the basis of _n_-gram counts from a text corpus. While a pretty basic approach to language generation, currently even the largest, state-of-the-art deep learning language models are still a direct generalization of this simple idea.
MW  If you haven't already, write a function that turns a Counter or dictionary of counts (such as those read from the above `.csv` files) into a dictionary of proportions, which will serve as (estimated) probabilities.
MW  Write a function that takes a (potentially empty) list of several tokens (representing the beginning of a sentence, e.g., _The dog chased the_), and a list containing one or more dictionaries of n-gram probabilities in order of decreasing _n_ (e.g., `[trigrams, bigrams, monograms]` assuming these are the names containing the n-gram probabilities), and returns a random next word for the sentence (e.g., _cat_). It should do this by probabilistically sampling a word, by first looking at the 3-grams for a partial match, if that fails at the 2-grams, and finally the 1-grams, for instance as follows (ignore the following suggestion if you like a puzzle!). \n - For every _n_ (e.g., 3, then 2, then 1), take the last _n_-1 words of the starting sentence (e.g., for 3-grams, and the sentence _The dog chased the_, take the last 2 words _chased the_) and create a list of all _n_-grams that start with this these _n_-1 words (e.g., _chased the mouse_, _chased the money_, etc.). \n - If that list is empty, decrement _n_ and try again (i.e., if no matching 3-grams are found, try the 2-grams instead, and if that fails use the 1-grams). \n - If a list of matching _n_-grams is found (or if _n_ == 1, simply take all 1-grams), use `random.choices` to choose randomly from among this list of _n_-grams, providing a list with their probabilities as the optional `weights` argument of `random.choices` (actually, the weights can also be raw counts, but using probabilities throughout is conceptually cleaner). \n - The function should then return the final word of the selected _n_-gram (e.g., _mouse_).
MW  Write a wrapper function that loads a `.csv` file with _n_-gram counts (from earlier exercises), turns them into proportions (probabilities), asks for an `input` from the user (a writing prompt, i.e., the start of a sentence), and then repeatedly uses the above generation function to generate words continuing the writing prompt. Make sure your generator stops either when a sentence separator is generated (e.g., a period `.`) -- assuming these are among your counted tokens! -- or when a chosen maximum of tokens has been generated.
MW  Use the previous function to inspect the quality of your language generator. For instance, compare the generated sentences if you use 4, 3, 2 and 1-grams vs. only 2 and 1-grams, or even only 1-grams. Do you observe differences in the type of generated language? Which is more human-like?
MW  Make sure the foregoing code also works at the character-level, i.e., if you provide it with character _n_-gram counts instead of word _n_-gram counts, and let it sample one character at a time. Consider using higher _n_-grams (e.g., 5-grams, 6-grams). What is your impression of the generated language? Can you think of pros/cons of character-level generation vs. word-level generation?
MW  State-of-the-art deep learning language models are, in essence (but grossly simplifying) still _n_-gram language models (and both character- and word-level models are actively used), but with much higher _n_ and stronger ability to generalize to unseen words and _n_-grams (due to 'hidden layers' in an artificial neural network). With this in mind, can you give one reason why these models need humungous datasets to train on? And can you explain why contrary to the hype of AI achieving 'language understanding', such models have been criticized as being mere 'stochastic parrots'? What, if anything, might make humans different from such models?
MW  Optional exploration: Apply your language generation pipeline (including the preparation step of generating a .csv file with _n_-gram counts) to a text file from a different genre (e.g., kids stories) or a different language.


Title	Pattern matching (regular expressions)

MW  We already encountered string methods for searching (`index`, `find`), replacing (`replace`) and splitting (`split`). But often one wants to search for (or replace by, split on) not a _literal_ substring, but a _pattern_, i.e., characterizing a _class_ of substrings. _Regular expressions_ are a powerful and convenient method for this, available in Python from the standard `re` library. As a first illustration, execute the following code and try to understand the result:\n```
import re

example_string = 'The famous Dr. Freud hastily acquired a T-shirt and an old sweater for 24.95EUR. He then eagerly left the H&M.'
print(re.findall('[aeiou]+', example_string))
```
MW  Enter `help(re)` or visit the (mostly equivalent) official documentation at https://docs.python.org/3/library/re.html for a global, initial impression; see especially the list of special characters in the section _Regular Expression Syntax_.
MW  Use `re.findall` to test (and try to understand) what patterns are defined by the following regular expressions (passed to `re.findall` as plain Python strings). Test the expressions on a suitably varied example string, e.g., `example_string` from above.\n - `[a-z]+` \n - `[a-zA-Z]+` \n - `[a-zA-Z ]+` \n - `[^a-z]` \n - `[aeiou]` \n - `[aeiou]*` \n - `[^aeiou .]+`
MW  It will be convenient for some of the following exercises to define a function that takes a _list_ of regular expressions and a string in which to search, and prints each regular expression on a separate line, alongside the list of matches that `re.findall` returns for that regular expression.
MW  With the help of the documentation at https://docs.python.org/3/library/re.html#regular-expression-syntax, try to _predict_ which substrings the following regular expressions will match. Test your predictions with the help of the function from the previous exercise (and you can also use the suggested `example_string` from above).\n - `[0-9]` \n - `[0-9]+` \n - `\d+` \n - `[a-z]+` \n - `[A-Z]+` \n - `[A-Za-z]+` \n - `[a-zA-Z]+` \n - `[A-Z]+[a-z]+` \n - `[A-Z]+[a-z]*` \n - `[^A-Za-z]+` \n - `[A-Za-z0-9]+` \n - `\w+` \n - `\w+s` \n - `\w+ly` \n - `[^\w]+` \n - `The|the` \n - `[Tt]he`

Note  **Regular expressions** are the go-to method for working with string _patterns_. Regular expressions form a special-purpose language, with its own little syntax, independently of (and older than) Python. In Python, the standard `re` module provides functions for searching, splitting on and replacing patterns defined by regular expressions.

MW  Does the regular expression `ab+c+d` match on the string `'abbccd'`? And on the string `'abbbcd'`?
MW  What is the difference between the regular expressions `[ab]c+`, `a[bc]+` and `[abc]+`? Is there a string on which all three patterns will return the same match? And a string where they all yield different matches?
MW  What is the difference between the regular expressions `a+|b+`, `a+b+` and `[ab]+`? Is there a string on which all three patterns will return the same match? And a string where they all yield different matches?
MW  Define a single regular expression that matches all occurrences of the determiners a(n)/the.
MW  Try to break various things, e.g., what happens if you use a regular expression with mismatching brackets (`[A-Z`), an incomplete character range (`[A-]`), or two plusses (`[a-z]++`)? Can you define a character range outside square brackets (e.g., `A-Z` on its own)?
MW  Looking back at previous examples, explain whether `findall` returns _all_ substrings that match a given regular expression, or only a specific subset. Do you understand why the matching procedure for regular expressions is called *greedy*?
MW  If you are a linguistics student, did you ever come across the _Chomsky hierarchy_? Where do so-called _regular languages_ -- those characterizable by regular expressions -- fit in this hierarchy? Could you characterize the grammar of a natural human language in a regular expression?
MW  You will have noticed that some characters, escaped by a backslash, have special meaning in a regular expression. For instance, `\w` matches any alphanumeric character (letters or numbers) and `\d` matches any digit (number). In the `re` documentation, look up the meanings of at least `\s`, `\b` and `\A`, and illustrate their meanings on suitable example strings.
P4L  Take a moment to appreciate the power of regular expressions; e.g., what would the plain Python code look like for achieving the same as a simple regular expression like `a.*b.*c.*d`?
MW  Recall that some backslashed characters have special meaning for the Python interpreter, such as `\n` for a newline or `\t` for a tab, and these are mostly handled as expected by the regular expression parser. Illustrate this with examples of your choice.
MW  The period `.` is not a special character for Python, but it can be for the regular expression parser: outside a square brackets context, the `.` matches _any_ character except newline. Accordingly, to match an _actual_ period, you need to escape it with backslash. Given this, predict what the following regular expressions mean, and verify your prediction on a relevant example string of your choice:\n - `.+` \n - `\.+` \n - `".+"`
MW  In a text of your choice (e.g., a book from the Gutenberg project), find all vowel clusters (single vowels or sequences thereof) and sort them by frequency, printing a top-20 of most frequent vowels and vowel clusters.
P4L  Do the same, but now for word-initial consonant clusters, and word-final consonant clusters.

MW  Thus far we have been using `findall` to test various regular expressions. But often we may want to search for a pattern and retrieve not only the matching substrings, but also the _locations_ of these matching substrings in the original string. Such information is returned by the function `re.finditer`, in the form of `Match` objects. Explore how this works by `for match in re.finditer('[a-z]+', example_string): ...`, printing each match object inside the loop.
MW  From a given `Match` object you can retrieve the matched span (`match.span()`) and the substring (`match.group()`). Modify the previous loop to print, instead of the `Match` objects themselves, more readable lines like `3-6: the` (representing a match with span (3, 6) and substring `the`).
MW  Why is the matching substring retrieved with a method called 'group'? Explore this with the regular expression `(\w+)ly`, in which the parentheses define a group (`(\w+)`). Use `re.finditer` to find all its matches on the `example_string` from earlier, and for each match print both the entire substring `match.group()` and the substring matching just the first group (`match.group(1)`).

Note    Parentheses in a regular expression define _capture groups_, and a `match` object contains an entry (substring and span) for each separate group. Whereas `match.group()` (in fact shorthand for `match.group(0)`) gives the substring that matches the entire regular expression, `match.group(1)`, `match.group(2)` etc. return a substring for each separate group of the regular expression. Groups let you retrieve substrings that occur in a given context.

MW  Define a regular expression containing a capture group, that lets you retrieve all vowel sequences (single vowels or multiple consecutive vowels) that are surrounded by consonants on both sides.
MW  What happens if your regular expression contains no round parentheses (i.e., no capture groups defined), and on a given match you call `match.group(1)`? What about `match.group(0)`?
MW  We have seen that `re.finditer` returns `Match` objects, from which you can retrieve the substrings for the different capture groups (if present). How does `re.findall` handle groups? Compare at least the regular expressions `(a)b`, `(a)(b)` and `((a)b)`. Verify your understanding by calling `help` on `re.findall`.
MW  If your regular expression defines a capture group, you can invoke it in the same regular expression with a backslash-number, e.g., `\1` refers to the first group, i.e., group 1 (with group 0 being reserved for the regular expression as a whole). Given this, what kinds of strings would the regular expression `(\w+) \1` match? Illustrate this with an example.
MW  Can you predict what happens if you apply the previous regular expression to the ridiculous-but-famous sentence `Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo`? Can you modify the regular expression so it matches not just pairs, but _n_-tuples of reduplicated words? If additionally you make it case-insensitive, it should return only a single match for the Buffalo example string.
MW  Write code to find a top-10 of the most frequently reduplicated words, in a text of your choice (e.g., Alice in Wonderland).
MW  Write a regular expression that finds all places where the same _character_ occurs three times in a row, and sort the results by frequency. What is the most frequent such triplet in the text of your choice?

MW  Although round parentheses `(...)` have a special meaning in Python's regular expressions (capture groups, extensions), you can also still use them for governing **operator precedence**. With this in mind, explain the difference between the four regular expressions `(ab)+`, `a+b+`, `ab+` and `(ab+)`. (Beware of using `re.findall` to explore this issue, given the way it implicitly handles groups; best use `re.finditer` instead.)
MW  We started this section with string methods `replace` and `split`. The module `re` provides analogous functions for replacing by and splitting on a regular expression instead of a literal string, namely `re.sub` (short for 'substitute') and `re.split`. Use these to (separately): \n - replace all vowels in a string by `a` \n - replace all adverbs in a given string by `badly` \n - replace all words that start with a capital letter by the name `Santa` \n - separate a string into words by splitting on spaces, tabs and punctuation \n - separate a string into sentences by splitting on periods, exclamation marks and question marks.
MW  Call `help` on `re.split` to read about what happens if you split on a regular expression that contains capturing parentheses (i.e., a capture group). Subsequently verify this by comparing splitting on `[.!?]+` vs. splitting on `([.!?]+)`.
MW  Sentence-splitting based on punctuation alone is inadequate. For instance, one should not split on the period in numbers such as `24.95` and abbreviations such as `Dr. Freud`. Define a more sophisticated sentence-splitting function, that, with the help of a list of common abbreviations, first replaces any non-splittable periods by the placeholder `<NOSPLIT>`, then splits on remaining punctuation as before, and in the resulting substrings put the non-splittable periods back. Apply your sentence-tokenizer to a larger text (e.g., Alice in Wonderland) and (by manually inspecting some random passages) estimate both the _recall_ (proportion of actual sentence-separators that were correctly identified and split on) and _precision_ (proportion of splits that are correct) of your sentence-tokenizer. Try to reduce any remaining errors. For instance, can it handle quotation marks?
***Compare this to SentTokenize of NTLK, Textblob, Spacy?  TextBlob NLTK word tokenizer PunktSentenceTokenizer uses regex, says so in the doc. The senttokenizer uses regex too, but less transparently.
MW  Write a function that (with the help of your sentence tokenizer and the way `re.split` handles groups), extracts questions from a text. Write another function that groups the questions you found based on the question-word and/or auxiliary verb. Which types of questions are the most frequent in a text of your choice?
***Suggest a particular text to use.
MW  Write a function that finds quotations in a text, meaning any passage contained in (matching) quotation marks. Be aware of the many types of quotation marks that can in principle be used (https://unicode-table.com/en/sets/quotation-marks/).
MW  Write a function that extracts all 'dialogues' from a text, where a dialogue is a series of consecutive quotations (previous exercise). Use the `span` method of the retrieved `Match` objects to ensure that quotes within a dialogue are less than some threshold of _N_ words apart; if they are farther apart, assume they belong to separate dialogues. With a big enough corpus of literature, do you think the resulting corpus could be used as a window on actual human dialogue? Why (not), or in which way(s)?


Subtitle    Optional appendix: using _raw_ strings to define regular expressions

MW  Since the backslash `\\` is a special 'escape' character for Python (i.e., it takes on a special meaning in various contexts, such as `\n` meaning newline), how do you create a string containing an _actual_ backslash? Compare `print('nice\nice\nice')` to `print('nice\\nice\\nice')` and explain the difference in your own words.
MW  The backslash is also a special character for the regular expression parser. So, how do you define a regular expression that contains an _actual_ backslash? Crucially, escaping it _once_ is not enough: Python interprets the string `'nice\\nice\\nice'` as, essentially, `nice\nice\nice`, and it is the latter that gets passed on to the regular expression parser, which will interpret the `\n` (which was defined in the Python string by `\\n`) as a newline. Verify this by matching `'nice\\nice\\nice'` as a regular expression on the following multi-line string:\n```
'''test nice
ice
ice test'''
```
MW  Because of the foregoing, you must make sure that the regular expression parser, too, receives double backslashes from Python, essentially `nice\\nice\\nice`. And defining the latter string (containing actual double backslashes) in Python requires  _quadruple_ backslashes, i.e., `'nice\\\\nice\\\\nice'`. Verify that the latter, when used to define a regular expression, no longer matches the previous multi-line string, but does match the single-line string `'test nice\\nice\\nice test'` (which, recall, is Python's representation of `test nice\nice\nice test`).
MW  Summarize the preceding exercises in your own words, e.g., why does defining a regular expression via an ordinary Python string sometimes require a quadruple backslash?
MW  To avoid quadruple backslashes in your regular expression definitions, it is customary (when defining regular expressions) to tell Python in advance _not_ to treat the backslash as an escape character, leaving all of them intact for the regular expression parser. This is done by defining what is called a **raw string**, identifiable by the prefix `r`. Predict what the following raw strings, when used to define regular expressions, will match (and verify your predictions):\n - `r'nice\nice\nice'` \n - `r'nice\\nice\\nice'` \n - `r'nice\\\\nice\\\\nice'`.

Note   Defining a regular expression involves two steps: first the Python interpreter parses your string definition (turning a piece of your code into a string object), and then the regular expression parser of the `re` module interprets that string object as a regular expression. Using **raw strings** like `r'abc'` makes the first of these two steps as straightforward as possible, thus simplifying the definition of regular expressions. (Note that raw strings are also used more generally, as they can improve the readability of your string definitions whenever your strings contain actual backslashes (possible use case: a Python script that helps you generate LaTeX code, a common, backslash-heavy language for typesetting academic papers).)

MW  To make sure you understand raw strings, predict the lengths (according to `len`, i.e., the number of characters) of the following strings and raw strings, keeping in mind that a special, escaped character like `\t` counts as 1: \n - `'t\t\t'` \n - `'t\\t\\t'` \n - `'t\\\\t\\\\t'` \n - `r't\t\t'` \n - `r't\\t\\t'` \n - `r't\\\\t\\\\t'`



Title   Advanced text processing

Note    There are many libraries for text processing. NLTK is a very general but not the most user-friendly or particularly up-to-date.
MW  import textblob check its main documentation page.
MW

***stopwords, nltk, textblob, spacy --> explain import
	***Maybe search as a theme, then use pattern-based (re), fuzzy (diflib) and meaning-based (embeddings)?
***Tokenizer (+ Set, Counter), senttokenizer
***Recursion, dependency tree traversal; though maybe also sentence generation AGAIN.
***Bit of machine learning?


***Also cool: https://github.com/jenojp/negspacy

***Note	pipeline of reading, modifying and printing; preprocessing, data structures

***iteration vs lists for big text input etc., fits here! also generator expressions and yield:  https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do   including this fun example: def f123():      yield 1;    yield 2;   yield 3;    for item in f123():     print item

P4L Write a program that converts active sentences in English to passive sentences. This means changing the verbal morphology and adjusting word order as required.

***OMG yes this: https://spacy.io/usage/rule-based-matching


***gensim here?**

Subtitle    Optional appendix: character encodings

***file encodings? also related: str.casefold
***https://www.w3resource.com/python-exercises/file/index.php



Title   Clearer code

MW	Your editor may be smart enough to highlight violations of 'Python style', adherence to which will enhance the readability of your code (in addition to docstrings and self-documenting code). The style guides are kept in the eighth _Python Enhancement Proposal_, PEP8 (https://www.python.org/dev/peps/pep-0008/). Have a look at it, and go through some of your previous code to make it PEP8-compliant if needed.

Note	Initially created and long-term maintained by Guido van Rossum, Python is a very open, community-driven programming language. It has come to be the way it is with the help of **Python Enhancement Proposals** or PEPs (https://www.python.org/dev/peps/). **PEP8** is Python's style guide (https://www.python.org/dev/peps/pep-0008/).

MW	Every aspect of the Python language has been purposefully designed, even though we may not always understand the purpose. Should you find yourself frustrated with Python, just enter `import this` in the interpreter and feel your calm returning. (The keyword `import` will be explained later.) The result is an easter egg based on PEP20, that captures some of Python's design principles in poetic form.

Subtitle    Comments vs. self-documenting code

MW	Besides style, documenting your code matters. So far you have been documenting your code in at least two ways: by adding hashtag-comments to explain specific lines (comments which are ignored by the Python interpreter), and by adding docstrings to your functions (not ignored by the interpreter, but treated as actual strings). However, quiet often `#`-comments can be rendered unnecessary by choosing more meaningful variable names, making the code more __self-documenting__. Can you change the variable name in the following snippet to make the following code self-documenting, so the `#`-comment can be deleted?\n```
d = {}  # create an empty dictionary that will contain word counts
```
MW	Make the following code self-documenting by both changing variable names and restructuring the for-loop (avoid the need for `range` and `i`):\n```
l = ['John', 'Sue', 'Bob', 'Chris']
# loop over all names in the list to print them
for i in range(len(l)):
    print(l[i])
```
MW	Make the following code self-documenting:\n```
mapping = {'John': '098124', 'Sue': '657317', 'Bob': '135809'}

x = '657317'    # this is the student ID that I need to know the name for

mapping2 = {a: b for b, a in mapping.items()}	# construct the inverse mapping
if x in mapping2:	# this means the student ID was in the original dictionary
    print(new_mapping[x])	# print the student's name
```
MW	For self-documenting code you must often resist the temptation to do too much in a single line of code. Improve the following code by, inside the for-loop, first assigning the computed value to a transparently named variable, and then printing that variable (i.e., instead of printing the output of the computation directly). In that way, the variable name can tell you its meaning. Feel free to make other changes too, to make the code more self-documenting:\n```
r = [7, 4, 5, 8, 6, 9, 5]
print('We have 7 circles!')
for i in range(7):
    print(3.1415 * r[i]**2)
```
MW	So called **magic numbers**, i.e., manually typed numbers in the middle of the code, are also bad for readability and maintainability. In the above example, you can replace two occurrences of the value `7` by `len(r)` (or whatever your name name for `r` is). You can also replace our own pi approximation by pi from Python's built-in math module: first `import math`, then you can use `math.pi`. (We will learn more about `import` later.) Can you think of reasons why 'magic numbers' are often bad?

Note	You can often greatly improve the clarity of your code by making it **self-documenting**. This is achieved by chunking your code into functions (especially the SLAP principle), and by choosing meaningful variable and function names. (However, variables used only for a few lines, such as a counter in a loop or an item in a list comprehension, can often be safely named with a single letter.)

MW	Make the following code as self-documenting as possible; you may have to change quite a bit! Also replace some of the magic numbers by transparently named variables defined at the start of the program instead of in the middle. \n```
python = ['John', 'Sue', 'Bob', 'Chris', 'Peter', 'Pjotr', 'Maria']  # all students of the python for linguists class
pts = [80, 60, 43, 75, 27, 92, 94]  # points they earned for the exam
total = 100
g = [10 * i/95 for i in pts]   # only 95 because 5 points were bonus
p = [i > 5.5 for i in g]
# now print the results in terms of pass/fail, followed by the number of failing students
print(p)
print(len([q for q in p if not q]))
print([s for i, s in enumerate(python) if not p[i]])	# these failed the exam
```
MW	If you have been adding `#`-comments to your code, go through any of your previous code and see if such comments can be rendered unnecessary by making the code self-documenting (if it isn't already).
MW	Variables with meaningful names inevitably carry the implication that they will be subsequently used. If this is not the case, i.e., for variables that will not be reused, the underscore `_` is conventionally used, as below. Go through your code to see if any variables could be replaced by `_` to make the code more readable:\n```
for _ in range(10):
    print("Hurrah!")
```
MW  A bit of an aside, but try executing something simple in the Python console that returns a value, like `38 * -2`, and then, on the next prompt, simply enter the underscore variable `_` and execute it. What special behavior does this show the underscore variable has in the interpreter? Does `_` work the same way in a Python script?
MW  Besides adequate variable and function names, another way to make your code more self-documenting is to use appropriate, informative _data structures_. Make the following code more self-documenting (and more safe) by using a dictionary instead of two lists:\n```
# Names of students and the corresponding (!) student IDs.
# Warning, if you change one list make sure you change the other!
names = ['John', 'Sue', 'Bob', 'Chris']
ids = ['124987', '098513', '098122', '198732']

# find the student ID of Bob:
index_of_bob = names.index("Bob")
x = ids[index_of_bob]

print(x)
```
MW  Make the following code more self-documenting (and safer, and in some ways much shorter), mainly by choosing better data structures:\n```
# student records consist of the fields name, age, student_id and major:
students = [
    ['John', 22, '1249871', 'linguistics'],
    ['Mary', 24, '4198712', 'psychology'],
    ['Bob', 32, '089123', 'mathematics'],
]

for x in students:
    if x[0] == 'Bob':   # name was in the first column, hence 0
        print(x[2])  # student id is in the third column, hence 2
        break
```
***Improve the following as a function for add_keep_unique or something?
***Set datastructure not yet introduced...
MW  What would be a suitable datastructure for the following use-case? Use it to make the following code more self-documenting (and again, more safe):\n```
unique_numbers = [1,6,3,2,5,7,9]    # warning: must contain every number only once!

new_number = 8
if new_number not in unique_numbers:    # to ensure each number remains unique
    unique_numbers.append(new_number)
```

***Maybe repeat collections? itemgetter? Counter?


Subtitle    Some handy built-ins to streamline your loops (`zip`, `enumerate`)

***Explain difference between list and generator expression.

MW  ***Expand intro** In general Python programmers are weary of _indices_. Example of code to be improved.

MW	Sometimes you want to loop over the elements of a list, while at the same time keeping track of the indices. The built-in function `enumerate` is great for this. Assuming you still have `names` defined, try the following:\n```
for i, name in enumerate(names):
    print(i, name)
```
MW	Note that looping over a list via `enumerate` iteratively assigns new values to _two_ variables, namely the counter and the element (`i` and `name`, in this example). What happens if you forget the `i` and do `for name in enumerate(names)`? What is the type of `name` in that case? And what happens if, conversely, you include the `i` but forget the `enumerate`, that is, `for i, name in names`?

Note	Use the built-in function `enumerate` to iterate over the elements of a list together with their indices. `enumerate` takes a list and iteratively yields _pairs_ (2-tuples) of an index and a list element. We will learn more about pairs (and more generally tuples) later.

MW	What happens if you print the object `enumerate(names)` directly? What is its `type`? Note that it is not an ordinary list; instead, an Enumerate object processes `names` _on demand_, numbering each element on the fly, without looking ahead. This avoids having to read the full list and construct a new 'numbered' list, which would unnecessarily take up memory and processing time. But it means that, if you want to collect all enumerated names in an ordinary list, you need to do so explicitly: `list(enumerate(names))`. What is the `type` of the elements in the resulting list? We will learn more about that type of object later.
MW  Predict what the outcome is of the following statements, and verify your understanding: \n- `list(enumerate(range(10)))` \n- `enumerate(10)` \n- `list(10)` \n- `list(zip(range(10), range(10)))` \n- `list(zip(range(10)))` \n- `list(enumerate(enumerate(range(10))))`
*** TODO practice more list comprehensions, also with dictionaries:  \n- `[str(i) + ': ' + name for i, name in enumerate(names)]` \n- `[i % 3 for i in range(20)]`

***Integrate these exercises:
MW	Use the list `names` used earlier above, and create an empty dictionary `names_inv`. Now use `enumerate` to loop through all index-name pairs of the list `names`, and assign these to the dictionary `names_inv` by using names as keys and the corresponding list indices as values. Explain why `names_inv` is a suitable name.
MW	Continuing from before, what do you expect is the result of `names_inv[names[3]]`? And what about `names[names_inv[names[3]]]`? And `names_inv[names[names_inv[names[3]]]]`? Test your expectations!
MW	How robust is your previous program? What happens if the original list of names contained the same name twice, and you try to construct its inverse? Explain what goes wrong.

***Again, start with code with indices, to be improved with zip.

MW	Sometimes you want to combine every element from one list, with each corresponding element from another. This can be done with `zip` -- can you see why it is called `zip`?\n```
for a, b in zip([1, 2, 3], [9, 8, 7]):
    print(a, b)
```
MW	In the above code, can you predict what happens if you use only one variable, e.g., `for a in zip(...):` (and adapt the print statement accordingly)? Or if you accidentally use three variables?
MW	What do you think will happen if `zip` is provided with two lists of unequal length? Test your expectation.
MW	As with `enumerate`, `zip` constructs its tuples on the fly. To create a list of pairs, you need to explicitly convert the `zip` object to a `list` again. You can also convert a `zip` object directly to a dictionary using `dict`. Are the results as you would expect?
MW	Suppose we have a list of place names and a list of inhabitant counts. Write a short function (the body could be a single line) that lets us combine both lists to form a dictionary from place names to inhabitant counts.
MW  What happens if `zip` is given the same list twice, e.g., `zip(names, names)`? What if it is given the same list twice, but once without the first element: `zip(names, names[1:])`? Explain how the latter could be used to loop through all the _bigrams_ of a text. How would you loop through all trigrams?
MW	Suppose we have two (disjoint) lists of names, `names1` and `names2`. You can create pairs of names with `name_pairs = list(zip(names1, names2))`. Does the following code achieve the same? As usual, make a prediction before trying it out.\n```
name_pairs = []
for name1 in names:
    for name2 in names:
        name_pairs.append((name1, name2))
```

Subtitle    Powerful list comprehensions with `any`, `all`

***Make this exercise: MW  `all([True, True, True])`, `any([True, True, True])`, `all([True, True, False])`, `any([True, True, False])`.
***Make this exercise: MW  `len` needs a list, `sum`, `any`, `all` etc. can take any generator description.
MW  By feeding `all` and `any` a list comprehension (or more generally a generator expression), you can check whether all or any of the elements meet a certain condition. For example, assuming we have a list of strings assigned to `words`, what does `any(len(word) >= 3 for word in words)` check for? Write a similar one-liner that checks whether all words are less than 10 characters long.
MW  Write three expressions, that check whether none, some, and all of the words contain the letter 't'.
MW  Can you think of a way to use built-in `sum` to _count_ the number of elements that meet a condition (i.e., more fine-grained than none/some/all)? You can rely on boolean `True` evaluating to `1` (and `False` to `0`) in a numerical context. Use this to write an expression that counts the number of words that have a length of at least 3.
MW  An alternative way to count how many elements meet a certain condition is to use `len`, applied to a list comprehension that keeps only the elements that meet the condition. Use this to write an alternative expression that does the same task as required for the previous exercise: count the number of words that have a length of at least 3. Which solution do you find more readable?
MW  Describe at an intuitive level the two approaches you just explored, i.e., using `sum` vs. using `len` to count how many elements meet a condition. How does each work?
MW  Assuming we have a list of strings assigned to `words`, try to describe in plain English what the following lines compute. First make a prediction, then test and verify your undestanding. Are there expressions among them that are equivalent? \n - `any(w[0].lower() in 'aeiou' for w in words)` \n - `all(w[0].lower() in 'aeiou' for w in words)` \n - `not any(w[0].lower() in 'aeiou' for w in words)` \n - `all(w[0].lower() not in 'aeiou' for w in words)` \n - `sum(w[0].lower() in 'aeiou' for w in words) >= 2` \n - `len([w for w in words if w[0].lower() in 'aeiou']) >= 2` \n - `not any(w[0].lower() not in 'aeiou' for w in words)`
MW  With the help of the newly acquired built-ins and techniques from this section, reimplement some functions from section 14, in particular `has_any_odd`, `has_only_odd`, `has_three_odd` and `has_at_most_n_vowels`.



Subtitle    Adding type hints to your functions

MW  ***not sure if include type hints:\n```
x: int = 1
x: str = 'Johnny'
```
MW ***Can you run the code when type hints are violated? (Does PyCharm execute mypy automatically?)
MW ***\n```
from typing import List, Dict, Set
# now we can do subscripted types:
my_list: List[List[int]] = []
mydict: Dict[str, bool]: {}
```



Title   Tabular data (`csv`, `pandas`, machine learning)

***Installation of non-base libraries.**
***https://www.w3schools.com/python/pandas/pandas_exercises.asp
***https://www.w3resource.com/python-exercises/pandas/index.php


***Bit of web scraping too?   https://www.w3resource.com/python-exercises/web-scraping/index.php



***Use actual csv file.
MW	Suppose we have a `.csv` file (comma-separated values) with student names, their grades for two assignments and an exam, and some feedback. It has lines like `John,5,3,7,Well done John!` and `Mary,6,3,8,You learned a lot this year.`. Write a function that takes a list of such lines (assuming we already have them available as strings) and turns them into a dictionary that maps each student name to an inner dictionary containing their grades. For instance, the (outer) dictionary would map `'John'` to the dictionary `{'assignment1': 5, 'assignment2': 3, 'exam': 4}`.
MW	To the (inner) dictionaries for each student, add a key `'average'` with as value the average of that student's grades, where the assignments count for 25% each and the exam 50%.
MW	How robust is your function? What if a student has a double name like `Anna Beth`? What if a student has a missing grade, like `Sue,1,,5,4,3,6`? Improve your function if necessary. Also provide it with a boolean argument `missing_as_zero`: if set to `True`, missing grades are treated as zeros before computing the average; if set to `False`, missing grades are ignored when computing the average (so the remaining grades make up the full 100%).



Title  Logistic regression (also bag-of-words, tf-idf; `sklearn`)
***Count vectorizer


MW	Did you remember to add docstrings to all your function definitions? Is your code as self-documenting as possible?
MW	Did you sufficiently chunk your code, adhering to the SLAP (Single Level of Abstraction Principle) and DRY (Don't Repeat Yourself) principles?
MW	Now that you know how to read text files, you can improve your anti-profanity echo-machine from before -- that repeats your input unless it is a profanity, and quits after five profanities -- by using a more extensive list of profanities, e.g., googling "list of curse words .txt" will get you to the list used by google: `https://code.google.com/archive/p/badwordslist/downloads`. Place this file on your computer in your current project's main directory, and write a program to read this file, store all profanities in a list or set data structure (which one makes more sense?), and use this to increase the vocabulary of your echo machine.






Title    Data from the web

***crawling html
***tweets?
***graphs: social network structure?




Title	Project management (`import`, `main`, `__name__`, testing, git)

MW	We have already seen some uses of the `import` keyword (e.g., `import random` to be able to use `random.randrange(1, 100)`). To understand how `import` works, create two files, `file_a.py` and `file_b.py`. In one, write `print('Hello from file_a.py!')`, in the other, `print('Hello from file_b.py!')`. To test, run `file_a.py`, and then run `file_b.py` separately.
MW	Now, at the top of `file_a.py`, add `import file_b`. Run `file_a.py` again and see what happens. Try to understand where the different printouts come from.
MW	In `file_b.py` define the function `print_spam` that prints the string _Here's some spam from file_b.py!_), but do not call this function in `file_b.py` itself. Instead, call it in `file_a.py`: since it imports `file_b.py`, you can call the function on the `file_b` module: `file_b.print_spam()`. Try this. Do any variables defined in `file_b.py` also become available via `import` into `file_a.py`, or only functions?
MW	In `file_a.py`, after importing `file_b`, do `print(file_b)` and `print(type(file_b))`. This shows that importing a Python file creates a _module_ object. All code in the imported file is executed relative to that object, such that any variables and functions defined have to be called as attributes on that object (e.g., `file_b.print_spam()`). Try `dir(file_b)` to see all names available on the `file_b` object. Note that `dir()` (when executed inside `file_a.py`) lists all names available in the global scope of the main file being run, i.e., `file_a.py`. Does `dir()` when executed inside `file_a.py` also list `file_b.print_spam`, or only the parent module `file_b` as a whole?

Note	When you `import` a file, the code in that file is executed (basically as if you would run it yourself, with one difference, see below), and any names (variables, names of functions) defined in that file become available as attributes on a module object constructed from that file.

MW	Previously we already imported standard Python modules using `import random` and `import math`, to make available a function like `random.randrange`, and the constant `math.pi`. Does importing standard Python modules result in a similar 'module' object as importing your own `file_b.py`?
MW	In PyCharm you can ctrl+click (or cmd+click) on `random` (e.g., its occurrence in `import random`, or in a call to `random.randrange`), which brings you to the file `random.py` which lives somewhere in your system.
MW	Play around with the foregoing code. What happens if you accidentally include the file extension `.py` in the `import` statement, e.g., `import file_b.py`?
MW	Modules and other Python objects have a special field called `__name__`. In `file_a.py` add the print statement `print('The internal name of file_a.py is:', __name__)`. In file_b.py add `print('The internal name of file_b.py is:', __name__)`. Execute each file, and try to understand what's going on.

Note	The `__name__` attribute of a script or module differs depending on whether a file is run as its own script, or imported by another. If it is run on its own, then `__name__ == '__main__'`; otherwise `__name__` will be derived from the filename of the imported file.

MW	Use the foregoing to change `file_b.py` as follows: create an if-clause that checks if the file is run as the main file. Move all the print-statements in `file_b.py` to the body of the if-statement: these are executed only if the file is run on its own, and not if it is imported elsewhere. Test this.
MW	What happens if, still in `file_b.py`, you also move the function definition of `print_spam` to the body of the if-clause? Can you still call the function from within `file_a.py`? (Revert this change for what follows.)
MW	If you are coding in PyCharm, note that the editor puts a little green 'run' arrow in the margin left of the if-clause: it recognizes that the code is meant to be run as a script, not (just) imported in another.
MW	A bit of an aside: functions have names too, e.g., try printing `max.__name__` for the built-in function `max`, or `file_b.print_spam.__name__` for your own function `print_spam`. What happens to the `__name__` property if you assign a function to a new variable, e.g., `get_maximum = max`? Is the function's name changed along with it?
MW	How does Python know where to find the right files to import? Do `import sys` (a standard module with various system tools) and then `print(sys.path)`. This lists all the paths (to memory locations somewhere on your computer) where Python will look, one after the other, to find a standard module or user-created file with a matching name.
MW	What if you create a file with the same name as an existing module, e.g., create `random.py` containing just a print statement `print('Greetings from fake random.py!')`, and then in `file_a.py` do `import random`. Does Python give priority to the standard module, or to the user-defined file? (You can test this for instance with `dir(random)`.)

Note	Some terminology: a _module_ is a single python file that is (meant to be) imported into another, while a _package_ is a collection of related modules that can be imported together. The term _library_ is sometimes used more loosely for some collection of code designed for a certain coherent set of purposes (in one or multiple modules). A python file that is meant to be run on its own is called a _script_.

MW	To solidify your understanding of `import`, create two new files, `file_c.py` and `file_d`, containing the code given below. Try to predict (and test) what gets printed if you execute `file_c.py`, and what if you execute `file_d.py`:\n```
# Put the following in file_c.py:
import file_d

print('Hohohoho!')

def laugh():
    print('Hahaha!')

if __name__ == '__main__':
    laugh()
    file_d.cry()

# Put the following in file_d.py:
def cry():
    print('Boohoo...')

if __name__ == '__main__':
    print('I\'m so sad...')

print('Ayayay!')
```
MW	Explore the foregoing code. Suggestions: what happens if, in `file_c.py`, you call `laugh` like this: `file_c.laugh()`? What happens if you try to import a file that does not exist, e.g., `import file_z`? What happens if a file tries to import itself? What happens if two files import each other (e.g., in `file_d.py` add `import file_c.py`)? What happens if you place an import statement at the bottom of your file instead of at the top? What happens if you create a file `file_e` _without_ the customary Python extension `.py`, and try to import it?

Note	Python files can both _define_ stuff (e.g., functions) and _do_ stuff (e.g., call functions, get user input, print output). By convention (and for good reason), a file should _do_ stuff only if it is run as the main script, i.e., if `__name__ == '__main__'`. That is why any function _calls_ should be placed under an if-clause that checks this. Put differently, importing a file should not have _side effects_. (This is related to the principle, mentioned earlier, that functions should either _return_ something or _do_ something (e.g., change an existing object, print something), not both.)

MW	Clean up the files `file_c.py` and `file_d.py` to adhere to the foregoing principle.

Note	Related to the foregoing: if a file is only meant to be imported, not run on its own, then it should _not_ contain a `__name__ == '__main__'` check! Including it signals to the user (and to an editor such as PyCharm) that you can run this script on its own.

MW	Recall from earlier that functions enable **encapsulation**: variables created in a local scope, such as a function definition, are not accessible elsewhere. Do you remember why encapsulation is generally good, i.e., why a lack of encapsulation is risky? Give an example.
MW	Any variables or functions defined in the _global scope_ of a program are not encapsulated, hence accessible elsewhere. In the file `file_c.py`, try whether the body of the main if-clause (under `if __name__ == '__main__'`) belongs to the global scope -- is a variable defined there, accessible within the function definition of `laugh`?
MW	To increase encapsulation, statements in the body of the main if-clause are typically moved into their own separate function `main`. For instance, for the file `file_c.py` this would look as follows. Verify that this indeed improves the encapsulation, by defining a variable in `main` and testing if you can reach it from within `laugh`.\n```
import file_d

def main():
    laugh()
    file_d.cry()

def laugh():
    print('Hahaha!')

if __name__ == '__main__':
    main()
```
MW	Restructure the file `file_d.py` in a similar way, i.e., replace the main if-clause's body by a call to a designated function `main`. Verify that everything works as before.

Note	From now on, for better encapsulation, you should do this for every file you create: define a `main` function that is called at the bottom of the file only if the file is run as main file, and put all your commands that 'do something' (hence that should _not_ be side-effects when importing the file elsewhere) into the `main` function (or in functions called by the `main` function).

MW	Python interprets files from top to bottom, right? Then how come in the restructured `file_d.py` above, `laugh` can be called within `main`, despite it being defined _after_ (i.e., below) `main`?
MW	Add docstrings to your functions, at least in files `file_c.py` and `file_d.py`. When importing a file, do you get access to the docstrings of its functions (try with `help`)?
MW  In the previous block of exercises we learned how to read text files. What happens if instead of _importing_ a python file, you read it with `open` and `read()` like before? Do you expect the resulting object to be a module, as with `import`? Test this.

Subtitle    Version management
***Version management (`git`)   easy in PyCharm.

Subtitle    Testing
Note	Test, test, test! Untested code is useless. Tested code _might_ be useful.



Title	Testing hypotheses (`pandas`, `matplotlib`, `sklearn`)


***Maybe mention testing and reproducibility (again?) in this section?



ENDFILE


Title	Objects, identity, equality, mutability


TP3	\n```
opposites = {"up": "down", "right": "wrong", "yes": "no"}
alias = opposites
copy = opposites.copy()
```


MW  What do you think is the relation between mutability and hashability? Why?

MW	Calling a class creates an instance of it; like str()! :D


AMY ***this one in CPython; does it work only in the interpreter, or also in a python file?  \n```
a = 256
b = 256
a is b

# vs.

a = 257
b = 257
a is b

# vs.

a = 257; b = 257
a is b
```

***floating point precision and identity:   `0.0 == -0.0` true, `0.0 is -0.0` false         `0.1 + 0.2 == 0.3` false    https://www.youtube.com/watch?v=Js99ciGwho0


***sorting a mixed list


What does this do?  max(set(lst), key=lst.count)




MW	Execute the following program:\n```
from collections import namedtuple

Student = namedtuple('Student', ['name', 'age', 'studentid'])

john = Student('John', 19, '123987')
```


Title   Building useful scripts

***what's the commands and args module called again?




Subtitle    Mini-adventure: Counting n-grams

MW  In the following exercises we will see if n-grams follow a Zipfian distribution just like individual words. We will be using some techniques from the Week 6 adventure that we haven't covered in the homework yet, so don't be afraid to copy-paste. Create a new Python file, where you either start from scratch or copy the entire Week 6 adventure code as your starting point.
MW  Go to https://www.gutenberg.org/ to download several books in 'plaintext' format (or use another source of text data of your choosing). In the same directory as your current Python file, create a folder `data` (if it doesn't exist yet) and put your downloaded text files in that folder (the same way as for our Week 6 adventure).
MW  In your Python program, read all of the text data from the aforementioned files and concatenate them into a single string. Tokenize this string (with some cleanup).
MW  Program (or copy from a previous homework section) an `ngrams` function that takes a list of tokens and an integer `n`, and returns a list of n-grams. It is best if these n-grams are themselves represented as strings (or tuples), not as lists of strings, because we will be using them as keys in a counting dictionary: only immutable objects can be dictionary keys.
MW  Write (or cleverly reuse...) a function that takes a list of n-grams (as strings) and returns their counts in a dictionary.
MW  Review how in our Week 6 adventure we sorted the tokens by their counts, and reuse this code to do the same for bigrams and trigrams. Print the 10 most frequent and 10 least frequent bigrams and trigrams.
MW  Do bigrams and trigrams show a Zipfian distribution? What are some differences compared to the distribution of single tokens? Is there some `n` for which the distribution of `n`-grams ceases to be (roughly) Zipfian? Can you reflect on why this might be?




Title   More about tuples (also `dict`, `zip`)

***The following are not too relevant:
MW	Write a function `fake_zip` that takes two arguments `list1` and `list2` and returns the same as `list(zip(list1, list2))`, but without using `zip`. Does it handle lists of unequal lengths the way `zip` does?
MW	Write two functions that together emulate a dictionary: `fake_add_to_dict` takes a list, a key and a value, and (i) if the list has no pair yet with the same key, append the pair to the list, (ii) if the list already has a pair with the same key, update the value of that key; `fake_get_from_dict` takes a list and a key, and (i) if the list has a pair with that key, return the corresponding value; (ii) if the list has no pair with that key, print an error. Test your functions rigorously.
MW	Write additional functions `fake_keys`, `fake_values` and `fake_items` that take a list of pairs and return a list of keys, values or full pairs. (Recall that the real `keys`, `values` and `items` methods of a dictionary do not return an ordinary list, but for our fake dictionary this suffices.)
MW	Do you remember to add docstrings to your function definitions?
MW	With minimal effort, make the keys in your fake dictionary case-insensitive, i.e., such that _Apple_ and _apple_ and _applE_ count as 'the same' key.
MW	Oh no! Our client wants to use our case-insensitive dictionary code on a game console from the seventies, with tiny memory! Change `fake_add_to_dict` so that the emulated dictionary can contain at most 10 items; if the dictionary is full, simply remove the oldest item to make room for the new item.





NED  In the following example, how come the list `nums` doesn't change?\n```
nums = [1, 2, 3]
for x in nums:
    x *= 10

print(nums)
```
MW  Change the above code to have it modify the list `nums` in-place. You can achieve this by only changing the header of the for-clause, and the `x` in its body...
MW  Can you generalize the previous code so it also works on strings, modifying them in-place?




***not needed MW	Can you think of (dis)advantages of using `range`, defined by a start and end point, instead of a list of all the numbers in that range? For instance, what if you want to loop over a billion gazillion numbers?


*** Not super relevant  Note	Try not to needlessly occupy memory and processing time: `range` lets you iterate over a sequence of integers without having to store the corresponding list of integers anywhere in memory.

***TP3	Write a function that takes a number `n` and prints out the first `n` triangular numbers. (For instance, the 5th triangular number is 1+2+3+4+5, i.e., 15.)
***TP3	Write a function that takes a number and prints `True` when it is a prime number and `False` otherwise.
***Nog relevant here MW	Define a function that uses nested loops to print all possible two-character strings where the first is a consonant and the second is a vowel.



***Far-fetched:  MW	Recall that you can directly convert a `range` object to a `list`, but not the other way around. Implement a function `list_to_range` that does allow this. Of course it can only work for lists that correspond to a certain range with an integer start point, end point and regular steps in between.

***Nah. MW	Now program a clock with both hours and minutes, printing it as, e.g., `16:52`, and let it run for two 'days' (each iteration simulates a minute). If it works, make it also display seconds, and run it for a few 'hours'.
***MW	Can you change the setting of your clock to display times using `am` and `pm` instead of the 24-hour format, e.g., `4:52pm` instead of `16:52`?





***String operation leftovers:
***Boring: P4E A spam detection program outputs strings containing a confidence value (between 0 and 1), like `'X-DSPAM-Confidence:0.8475'` (meaning it is pretty confident that it is spam). Write a function that extracts the confidence value, in two ways. The first version should use `find` and string slicing. The second version should use `split` and list slicing. In each case, print the confidence that it _isn't_ spam, defined as 1 minus the confidence.
***Boring: TP3	Suppose any line of text can contain at most one url that starts with `http://` and ends at the next space in the line. Write a function that takes a line of text and extracts the full url if it is present.
***Boring and no need for tokenization here.  MW	A business client wants us to implement a function that uses `split` to divide potentially long meeting reports into separate sentences; this is sometimes called **sentence tokenization**. Assume that we already have each meeting report available to us as a plain Python string object. The function should take a string and return a list of strings, i.e., the sentences. Build a prototype, but also explain to your client the limitations of sentence-tokenizing using `split`, with the help of concrete examples. Limitations could pertain to either empirical adequacy or maintainability/clarity of the code.
***Doesn't add much. MW	Despite the limitations, our client was happy. Now they want another function that word-tokenizes a sentence, i.e., that takes a string and returns a list of separated words. Build a prototype, but also explain to your client the limitations of word-tokenizing using `split`.

***https://www.w3resource.com/python-exercises/re/index.php






Title   Building useful and reliable tools
***Turning your script into a useful command-line tool; command line sys.args, piping,
***check OS interoperability; shebangs?  #!/usr/bin/env python
***using the **click** library


***Bytecode disassembler?





https://github.com/JaDogg/summarized_books/tree/master/clean_code


I've done:
TP3 up to chapter 4 (excluding turtle exercises).
TP2 up to chapter 3. 	excluding stack diagrams, turtle exercises.
P4E up to chapter 3.
P4L up to chapter 3.3.
AMY https://www.youtube.com/watch?v=sH4XF6pKKmk
NED https://www.youtube.com/watch?v=_AEJHKGk9ns&t=2s




